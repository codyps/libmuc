   1               		.file	"adc.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.global __do_copy_data
   8               		.global __do_clear_bss
  11               		.text
  12               	.Ltext0:
 103               	.global	copysign
 105               	copysign:
 106               		.stabd	46,0,0
 108               	.Ltext1:
   1:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** /* Copyright (c) 2002,2007 Michael Stumpf
   2:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
   3:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****    Portions of documentation Copyright (c) 1990 - 1994
   4:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****    The Regents of the University of California.
   5:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
   6:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****    All rights reserved.
   7:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
   8:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****    Redistribution and use in source and binary forms, with or without
   9:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****    modification, are permitted provided that the following conditions are met:
  10:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
  11:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****    * Redistributions of source code must retain the above copyright
  12:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      notice, this list of conditions and the following disclaimer.
  13:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
  14:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****    * Redistributions in binary form must reproduce the above copyright
  15:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      notice, this list of conditions and the following disclaimer in
  16:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      the documentation and/or other materials provided with the
  17:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      distribution.
  18:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
  19:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****    * Neither the name of the copyright holders nor the names of
  20:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      contributors may be used to endorse or promote products derived
  21:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      from this software without specific prior written permission.
  22:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
  23:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  24:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  25:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  26:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  27:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  28:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  29:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  30:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  31:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  32:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  33:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   POSSIBILITY OF SUCH DAMAGE. */
  34:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
  35:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** /* $Id: math.h,v 1.21.2.1 2008/03/17 15:28:49 arcanum Exp $ */
  36:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
  37:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** /*
  38:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****    math.h - mathematical functions
  39:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
  40:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****    Author : Michael Stumpf
  41:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****             Michael.Stumpf@t-online.de
  42:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
  43:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****    __ATTR_CONST__ added by marekm@linux.org.pl for functions
  44:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****    that "do not examine any values except their arguments, and have
  45:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****    no effects except the return value", for better optimization by gcc.
  46:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****  */
  47:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
  48:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** #ifndef __MATH_H
  49:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** #define __MATH_H
  50:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
  51:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** /** \file */
  52:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** /** \defgroup avr_math <math.h>: Mathematics
  53:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****     \code #include <math.h> \endcode
  54:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
  55:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****     This header file declares basic mathematics constants and
  56:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****     functions.
  57:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
  58:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****     \par Notes:
  59:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****     - In order to access the functions delcared herein, it is usually
  60:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****       also required to additionally link against the library \c libm.a.
  61:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****       See also the related \ref faq_libm "FAQ entry".
  62:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****     - Math functions do not raise exceptions and do not change the
  63:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****       \c errno variable. Therefore the majority of them are declared
  64:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****       with const attribute, for better optimization by GCC.	*/
  65:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
  66:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** /**
  67:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****    \ingroup avr_math
  68:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
  69:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****    The constant \c pi. */
  70:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** #define M_PI 3.141592653589793238462643
  71:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
  72:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** /**
  73:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****    \ingroup avr_math
  74:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
  75:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****    The square root of 2. */
  76:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** #define M_SQRT2 1.4142135623730950488016887
  77:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
  78:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** /**
  79:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****    \ingroup avr_math
  80:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
  81:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****    NAN constant. */
  82:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** #define NAN	__builtin_nan("")
  83:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
  84:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** /**
  85:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****    \ingroup avr_math
  86:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
  87:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****    INFINITY constant. */
  88:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** #define INFINITY	__builtin_inf()
  89:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
  90:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** #ifndef __ATTR_CONST__
  91:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** # define __ATTR_CONST__ __attribute__((__const__))
  92:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** #endif
  93:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
  94:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** #ifdef __cplusplus
  95:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** extern "C" {
  96:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** #endif
  97:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
  98:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   /**
  99:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      \ingroup avr_math
 100:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 101:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      The cos() function returns the cosine of \a __x, measured in radians.
 102:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   */
 103:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** extern double cos(double __x) __ATTR_CONST__;
 104:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 105:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   /**
 106:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      \ingroup avr_math
 107:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 108:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      The fabs() function computes the absolute value of a floating-point
 109:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      number \a __x.
 110:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   */
 111:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** extern double fabs(double __x) __ATTR_CONST__;
 112:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** #if 0
 113:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** /* fabs seems to be built in already */
 114:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** extern inline double fabs( double __x )
 115:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   { double __res;
 116:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****     __asm__ __volatile__ ("andi %D0,0x7F \n\t"
 117:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 		: "=d" (__res) : "0" (__x) );
 118:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****     return __res;
 119:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   }
 120:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** #endif
 121:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 122:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   /**
 123:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      \ingroup avr_math
 124:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 125:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      The function fmod() returns the floating-point remainder of <em>__x /
 126:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      __y</em>.
 127:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   */
 128:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** extern double fmod(double __x, double __y) __ATTR_CONST__;
 129:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 130:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   /**
 131:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      \ingroup avr_math
 132:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 133:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      The modf() function breaks the argument \a __x into integral and
 134:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      fractional parts, each of which has the same sign as the argument. 
 135:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      It stores the integral part as a double in the object pointed to by
 136:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      \a __iptr.
 137:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 138:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      The modf() function returns the signed fractional part of \a __x.
 139:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      
 140:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      \note
 141:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      This implementation skips writing by zero pointer.
 142:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   */
 143:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** extern double modf(double __x, double *__iptr);
 144:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 145:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   /**
 146:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      \ingroup avr_math
 147:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 148:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      The sin() function returns the sine of \a __x, measured in radians.
 149:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   */
 150:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** extern double sin(double __x) __ATTR_CONST__;
 151:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 152:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   /**
 153:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      \ingroup avr_math
 154:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 155:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      The sqrt() function returns the non-negative square root of \a __x.
 156:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   */
 157:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** extern double sqrt(double __x) __ATTR_CONST__;
 158:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 159:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   /**
 160:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      \ingroup avr_math
 161:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 162:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      The tan() function returns the tangent of \a __x, measured in
 163:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      radians.
 164:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   */
 165:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** extern double tan(double __x) __ATTR_CONST__;
 166:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 167:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   /**
 168:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      \ingroup avr_math
 169:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 170:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      The floor() function returns the largest integral value less than or
 171:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      equal to \a __x, expressed as a floating-point number.
 172:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   */
 173:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** extern double floor(double __x) __ATTR_CONST__;
 174:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 175:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   /**
 176:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      \ingroup avr_math
 177:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 178:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      The ceil() function returns the smallest integral value greater than
 179:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      or equal to \a __x, expressed as a floating-point number.
 180:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   */
 181:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** extern double ceil(double __x) __ATTR_CONST__;
 182:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 183:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   /**
 184:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      \ingroup avr_math
 185:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 186:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      The frexp() function breaks a floating-point number into a normalized
 187:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      fraction and an integral power of 2.  It stores the integer in the \c
 188:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      int object pointed to by \a __pexp.
 189:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 190:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      If \a __x is a normal float point number, the frexp() function
 191:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      returns the value \c v, such that \c v has a magnitude in the
 192:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      interval [1/2, 1) or zero, and \a __x equals \c v times 2 raised to
 193:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      the power \a __pexp. If \a __x is zero, both parts of the result are
 194:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      zero. If \a __x is not a finite number, the frexp() returns \a __x as
 195:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      is and stores 0 by \a __pexp.
 196:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 197:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      \note  This implementation permits a zero pointer as a directive to
 198:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      skip a storing the exponent.
 199:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   */
 200:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** extern double frexp(double __x, int *__pexp);
 201:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 202:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   /**
 203:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      \ingroup avr_math
 204:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 205:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      The ldexp() function multiplies a floating-point number by an integral
 206:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      power of 2.
 207:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 208:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      The ldexp() function returns the value of \a __x times 2 raised to
 209:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      the power \a __exp.
 210:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   */
 211:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** extern double ldexp(double __x, int __exp) __ATTR_CONST__;
 212:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 213:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   /**
 214:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      \ingroup avr_math
 215:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 216:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      The exp() function returns the exponential value of \a __x.
 217:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   */
 218:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** extern double exp(double __x) __ATTR_CONST__;
 219:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 220:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   /**
 221:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      \ingroup avr_math
 222:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 223:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      The cosh() function returns the hyperbolic cosine of \a __x.
 224:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   */
 225:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** extern double cosh(double __x) __ATTR_CONST__;
 226:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 227:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   /**
 228:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      \ingroup avr_math
 229:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 230:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      The sinh() function returns the hyperbolic sine of \a __x.
 231:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   */
 232:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** extern double sinh(double __x) __ATTR_CONST__;
 233:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 234:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   /**
 235:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      \ingroup avr_math
 236:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 237:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      The tanh() function returns the hyperbolic tangent of \a __x.
 238:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   */
 239:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** extern double tanh(double __x) __ATTR_CONST__;
 240:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 241:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   /**
 242:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      \ingroup avr_math
 243:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 244:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      The acos() function computes the principal value of the arc cosine of
 245:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      \a __x.  The returned value is in the range [0, pi] radians. A domain
 246:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      error occurs for arguments not in the range [-1, +1].
 247:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   */
 248:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** extern double acos(double __x) __ATTR_CONST__;
 249:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 250:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   /**
 251:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      \ingroup avr_math
 252:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 253:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      The asin() function computes the principal value of the arc sine of
 254:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      \a __x.  The returned value is in the range [-pi/2, pi/2] radians. A
 255:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      domain error occurs for arguments not in the range [-1, +1].
 256:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   */
 257:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** extern double asin(double __x) __ATTR_CONST__;
 258:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 259:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   /**
 260:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      \ingroup avr_math
 261:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 262:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      The atan() function computes the principal value of the arc tangent
 263:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      of \a __x.  The returned value is in the range [-pi/2, pi/2] radians.
 264:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   */
 265:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** extern double atan(double __x) __ATTR_CONST__;
 266:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 267:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   /**
 268:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      \ingroup avr_math
 269:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      
 270:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      The atan2() function computes the principal value of the arc tangent
 271:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      of <em>__y / __x</em>, using the signs of both arguments to determine
 272:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      the quadrant of the return value.  The returned value is in the range
 273:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      [-pi, +pi] radians.
 274:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   */
 275:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** extern double atan2(double __y, double __x) __ATTR_CONST__;
 276:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 277:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   /**
 278:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      \ingroup avr_math
 279:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 280:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      The log() function returns the natural logarithm of argument \a __x.
 281:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****    */
 282:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** extern double log(double __x) __ATTR_CONST__;
 283:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 284:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   /**
 285:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      \ingroup avr_math
 286:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 287:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      The log10() function returns the logarithm of argument \a __x to base
 288:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      10.
 289:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****    */
 290:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** extern double log10(double __x) __ATTR_CONST__;
 291:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 292:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   /**
 293:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      \ingroup avr_math
 294:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 295:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      The function pow() returns the value of \a __x to the exponent \a __y.
 296:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   */
 297:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** extern double pow(double __x, double __y) __ATTR_CONST__;
 298:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 299:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   /**
 300:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      \ingroup avr_math
 301:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 302:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      The function isnan() returns 1 if the argument \a __x represents a
 303:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      "not-a-number" (NaN) object, otherwise 0.
 304:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   */
 305:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** extern int isnan(double __x) __ATTR_CONST__;
 306:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 307:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   /**
 308:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      \ingroup avr_math
 309:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 310:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      The function isinf() returns 1 if the argument \a __x is positive
 311:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      infinity, -1 if \a __x is negative infinity, and 0 otherwise.
 312:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   */
 313:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** extern int isinf(double __x) __ATTR_CONST__;
 314:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 315:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   /**
 316:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      \ingroup avr_math
 317:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 318:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      The function square() returns <em>__x * __x</em>.
 319:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 320:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      \note
 321:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      This function does not belong to the C standard definition.
 322:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   */
 323:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** extern double square(double __x) __ATTR_CONST__;
 324:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 325:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   /**
 326:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      \ingroup avr_math
 327:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 328:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      The copysign() function returns \a __x but with the sign of \a __y.
 329:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      They work even if \a __x or \a __y are NaN or zero.
 330:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****  */
 331:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** __ATTR_CONST__ extern inline double copysign (double __x, double __y)
 332:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** {
 333:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****     __asm__ (
 110               	.LM0:
 111               	.LFBB1:
 112               	/* prologue: function */
 113               	/* frame size = 0 */
 115               	.LM1:
 116               	/* #APP */
 117               	 ;  333 "/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h" 1
 118 0000 57FB      		bst	r21, 7	
 119 0002 97F9      		bld	r25, 7	
 120               	 ;  0 "" 2
 121               	/* epilogue start */
 334:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 	"bst	%D2, 7	\n\t"
 335:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 	"bld	%D0, 7	"
 336:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 	: "=r" (__x)
 337:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 	: "0" (__x), "r" (__y) );
 338:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****     return __x;
 339:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** }
 123               	.LM2:
 124               	/* #NOAPP */
 125 0004 0895      		ret
 127               	.Lscope1:
 129               		.stabd	78,0,0
 132               	.global	isfinite
 134               	isfinite:
 135               		.stabd	46,0,0
 340:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 341:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   /**
 342:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      \ingroup avr_math
 343:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 344:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      The fdim() function returns <em>max(__x - __y, 0)</em>. If \a __x or
 345:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      \a __y or both are NaN, NaN is returned.
 346:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   */
 347:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** extern double fdim (double __x, double __y) __ATTR_CONST__;
 348:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 349:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   /**
 350:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      \ingroup avr_math
 351:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 352:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      The fma() function performs floating-point multiply-add. This is the
 353:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      operation <em>(__x * __y) + __z</em>, but the intermediate result is
 354:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      not rounded to the destination type.  This can sometimes improve the
 355:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      precision of a calculation.
 356:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   */
 357:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** extern double fma (double __x, double __y, double __z) __ATTR_CONST__;
 358:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 359:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   /**
 360:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      \ingroup avr_math
 361:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 362:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      The fmax() function returns the greater of the two values \a __x and
 363:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      \a __y. If an argument is NaN, the other argument is returned. If
 364:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      both arguments are NaN, NaN is returned.
 365:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   */
 366:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** extern double fmax (double __x, double __y) __ATTR_CONST__;
 367:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 368:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   /**
 369:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      \ingroup avr_math
 370:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 371:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      The fmin() function returns the lesser of the two values \a __x and
 372:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      \a __y. If an argument is NaN, the other argument is returned. If
 373:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      both arguments are NaN, NaN is returned.
 374:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   */
 375:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** extern double fmin (double __x, double __y) __ATTR_CONST__;
 376:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 377:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   /**
 378:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      \ingroup avr_math
 379:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 380:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      The signbit() function returns a nonzero value if the value of \a __x
 381:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      has its sign bit set.  This is not the same as `\a __x < 0.0',
 382:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      because IEEE 754 floating point allows zero to be signed. The
 383:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      comparison `-0.0 < 0.0' is false, but `signbit (-0.0)' will return a
 384:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      nonzero value.
 385:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      
 386:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      \note
 387:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      This implementation returns 1 if sign bit is set.
 388:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   */
 389:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** extern int signbit (double __x) __ATTR_CONST__;
 390:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 391:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   /**
 392:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      \ingroup avr_math
 393:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 394:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      The trunc() function rounds \a __x to the nearest integer not larger
 395:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      in absolute value.
 396:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   */
 397:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** extern double trunc (double __x) __ATTR_CONST__;
 398:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 399:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   /**
 400:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      \ingroup avr_math
 401:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 402:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      The isfinite() function returns a nonzero value if \a __x is finite:
 403:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      not plus or minus infinity, and not NaN.
 404:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   */
 405:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** __ATTR_CONST__ extern inline int isfinite (double __x)
 406:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** {
 137               	.LM3:
 138               	.LFBB2:
 139               	/* prologue: function */
 140               	/* frame size = 0 */
 407:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****     unsigned char __exp;
 408:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****     __asm__ (
 142               	.LM4:
 143               	/* #APP */
 144               	 ;  408 "/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h" 1
 145 0006 682F      		mov	r22, r24		
 146 0008 660F      		lsl	r22		
 147 000a 692F      		mov	r22, r25		
 148 000c 661F      		rol	r22		
 149               	 ;  0 "" 2
 150               	/* #NOAPP */
 151 000e 20E0      		ldi r18,lo8(0)
 152 0010 30E0      		ldi r19,hi8(0)
 153 0012 6F3F      		cpi r22,lo8(-1)
 154 0014 01F0      		breq .L4
 155 0016 21E0      		ldi r18,lo8(1)
 156 0018 30E0      		ldi r19,hi8(1)
 157               	.L4:
 409:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 	"mov	%0, %C1		\n\t"
 410:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 	"lsl	%0		\n\t"
 411:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 	"mov	%0, %D1		\n\t"
 412:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 	"rol	%0		"
 413:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 	: "=r" (__exp)
 414:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 	: "r" (__x)	);
 415:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****     return __exp != 0xff;
 416:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** }
 159               	.LM5:
 160 001a C901      		movw r24,r18
 161               	/* epilogue start */
 162 001c 0895      		ret
 167               	.Lscope2:
 169               		.stabd	78,0,0
 173               	.global	max
 175               	max:
 176               		.stabd	46,0,0
 178               	.Ltext2:
   1:adc.c         **** /*
   2:adc.c         **** Controls and Provides access to the Analog to Digital Converter (ADC) subsystem of the avr
   3:adc.c         **** */
   4:adc.c         **** 
   5:adc.c         **** #include "defines.h"
   6:adc.c         **** #include "adc.h"
   7:adc.c         **** #include <avr/interrupt.h>
   8:adc.c         **** #include <avr/io.h>
   9:adc.c         **** #include <avr/sleep.h>
  10:adc.c         **** #include <avr/power.h>
  11:adc.c         **** #include <stdio.h>
  12:adc.c         **** #include <math.h>
  13:adc.c         **** #include <util/delay_basic.h>
  14:adc.c         **** #include <avr/pgmspace.h>
  15:adc.c         **** #include <string.h>
  16:adc.c         **** 
  17:adc.c         **** uint8_t max(uint16_t val[],uint8_t sz) {
 180               	.LM6:
 181               	.LFBB3:
 182               	/* prologue: function */
 183               	/* frame size = 0 */
 184 001e 862F      		mov r24,r22
 185               	/* epilogue start */
  18:adc.c         **** 	uint8_t tmpi=sz,tmpv=0;
  19:adc.c         **** 	for(uint8_t c=0;c<sz;++c)
  20:adc.c         **** 		if (val[c]<tmpv) {
  21:adc.c         **** 			tmpi=c;
  22:adc.c         **** 			tmpv=val[c];
  23:adc.c         **** 		}
  24:adc.c         **** 	return tmpi;
  25:adc.c         **** }
 187               	.LM7:
 188 0020 0895      		ret
 190               	.Lscope3:
 192               		.stabd	78,0,0
 195               	.global	adc_get_val
 197               	adc_get_val:
 198               		.stabd	46,0,0
  26:adc.c         **** 
  27:adc.c         **** void print_adc_values() {
  28:adc.c         **** 	fprintf_P(stderr,PSTR("\n[debug]   RAW ADC: "));
  29:adc.c         **** 	for (uint8_t chan=0;chan<channel_amt;chan++) 
  30:adc.c         **** 		fprintf(stderr," [ %d : %d ] ", chan, adc_val[chan]);
  31:adc.c         **** 	
  32:adc.c         **** 	fprintf_P(stderr,PSTR("\n[debug] FIXED ADC: "));
  33:adc.c         **** 	for (uint8_t chan=0;chan<channel_amt;chan++) 
  34:adc.c         **** 		fprintf(stderr," [ %d : %d ] ", chan, adc_get_val(chan));
  35:adc.c         **** }
  36:adc.c         **** 
  37:adc.c         **** void print_adc_calibration() {
  38:adc.c         **** 	fprintf_P(stderr,PSTR("\n[debug] ADC OFFSETS: "));
  39:adc.c         **** 	for (uint8_t chan=0;chan<channel_amt;chan++) 
  40:adc.c         **** 		fprintf(stderr," [ %d : %d ] ", chan, adc_offset[chan]);
  41:adc.c         **** }
  42:adc.c         **** 
  43:adc.c         **** 
  44:adc.c         **** uint16_t adc_get_val(uint8_t ch) {
 200               	.LM8:
 201               	.LFBB4:
 202               	/* prologue: function */
 203               	/* frame size = 0 */
  45:adc.c         **** 	return adc_val[ch]+adc_offset[ch];
 205               	.LM9:
 206 0022 E82F      		mov r30,r24
 207 0024 F0E0      		ldi r31,lo8(0)
 208 0026 EE0F      		lsl r30
 209 0028 FF1F      		rol r31
 210 002a DF01      		movw r26,r30
 211 002c A050      		subi r26,lo8(-(adc_val))
 212 002e B040      		sbci r27,hi8(-(adc_val))
 213 0030 E050      		subi r30,lo8(-(adc_offset))
 214 0032 F040      		sbci r31,hi8(-(adc_offset))
 215 0034 2081      		ld r18,Z
 216 0036 3181      		ldd r19,Z+1
 217 0038 8D91      		ld r24,X+
 218 003a 9C91      		ld r25,X
 219 003c 280F      		add r18,r24
 220 003e 391F      		adc r19,r25
  46:adc.c         **** }
 222               	.LM10:
 223 0040 C901      		movw r24,r18
 224               	/* epilogue start */
 225 0042 0895      		ret
 227               	.Lscope4:
 229               		.stabd	78,0,0
 232               	.global	adc_set_channel
 234               	adc_set_channel:
 235               		.stabd	46,0,0
  47:adc.c         **** 
  48:adc.c         **** static uint8_t num_calibrations;
  49:adc.c         **** void adc_calibrate_update() {
  50:adc.c         **** 	int16_t offsets[channel_amt];
  51:adc.c         **** 	uint16_t adc_val_cpy[channel_amt];
  52:adc.c         **** 	memcpy(adc_val_cpy,adc_val,sizeof(adc_val));
  53:adc.c         **** 	
  54:adc.c         **** 	
  55:adc.c         **** 	uint8_t i=0,val=0;
  56:adc.c         **** 	for(uint8_t c=0;c<channel_amt;++c) {
  57:adc.c         **** 		if(val>adc_val_cpy[c]) {
  58:adc.c         **** 			i=c;
  59:adc.c         **** 			val=adc_val_cpy[c];
  60:adc.c         **** 		}
  61:adc.c         **** 	}
  62:adc.c         **** 	
  63:adc.c         **** 	for(uint8_t c=0;c<channel_amt;++c) {
  64:adc.c         **** 		offsets[c]=adc_val_cpy[i]-adc_val_cpy[c];
  65:adc.c         **** 	}
  66:adc.c         **** 		
  67:adc.c         **** 	if (num_calibrations==0)
  68:adc.c         **** 		memcpy(adc_offset,offsets,sizeof(adc_offset));
  69:adc.c         **** 	else
  70:adc.c         **** 		for(uint8_t c=0;c<channel_amt;++c) {
  71:adc.c         **** 			adc_offset[c]=(adc_offset[c] * num_calibrations + offsets[c])/(num_calibrations+1);
  72:adc.c         **** 		}
  73:adc.c         **** 			
  74:adc.c         **** 	++num_calibrations;
  75:adc.c         **** }
  76:adc.c         **** 
  77:adc.c         **** void adc_calibrate_store() {
  78:adc.c         **** 	fprintf_P(stderr,PSTR("\n[debug] Warning: unimplimented function adc_calibrate_store called"));
  79:adc.c         **** }
  80:adc.c         **** 
  81:adc.c         **** void adc_calibrate_clear() {
  82:adc.c         **** 	//for(uint8_t j= 0;j<channel_amt;++j)
  83:adc.c         **** 	//	adc_offset[j]=0;
  84:adc.c         **** 	memset(adc_offset,0,sizeof(adc_offset));
  85:adc.c         **** 	num_calibrations = 0;
  86:adc.c         **** }
  87:adc.c         **** 
  88:adc.c         **** void adc_init() {
  89:adc.c         **** 	#ifdef debug
  90:adc.c         **** 	fprintf_P(stderr,PSTR("\nadc: init"));
  91:adc.c         **** 	#endif
  92:adc.c         **** 	power_adc_enable();
  93:adc.c         **** 
  94:adc.c         **** 	//Set Voltage to AVCC with external capacitor at AREF pin
  95:adc.c         **** 	ADMUX|= (uint8_t)(1<<REFS0);
  96:adc.c         **** 	ADMUX&=(uint8_t)~(1<<REFS1);
  97:adc.c         **** 	//ADMUX&=~(1<<ADLAR); // Default disabled
  98:adc.c         **** 	
  99:adc.c         **** 	// Enable ADC, Inturupt, Trigger mode and set prescaler
 100:adc.c         **** 	//ADCSRA=(((1<<ADEN)|(1<<ADIE)|(1<<ADATE))&0b11111000)|(ADC_PRESCALE);
 101:adc.c         **** 	ADCSRA|= (uint8_t)(1<<ADEN)|(1<<ADIE)|(1<<ADATE);
 102:adc.c         **** 	ADCSRA = (uint8_t)(ADCSRA & 0b11111000)|((uint8_t)ADC_PRESCALE);
 103:adc.c         **** 	
 104:adc.c         **** 	// Enable Free Running Mode 
 105:adc.c         **** 	ADCSRB|= (1<<7); //reserved bit.
 106:adc.c         **** 	ADCSRB&= (uint8_t)~(0b111); //(ADTS2:0)=0
 107:adc.c         **** 	
 108:adc.c         **** 	// Disable Digital reads from analog pins
 109:adc.c         **** 	DIDR0 |= (uint8_t)((1<<ADC4D)|(1<<ADC5D)|(1<<ADC6D)|(1<<ADC7D));
 110:adc.c         **** 	
 111:adc.c         **** 	set_sleep_mode(SLEEP_MODE_ADC);
 112:adc.c         **** 	#ifdef debug	
 113:adc.c         **** 	fprintf_P(stderr,PSTR("\nadc: init: setup convertions"));
 114:adc.c         **** 	#endif
 115:adc.c         **** 	adc_set_channel(curr_ch);
 116:adc.c         **** 	//Start the convertions
 117:adc.c         **** 	ADCSRA|= (1<<ADSC);
 118:adc.c         **** 
 119:adc.c         **** 	// Wait one adc clock cycle and change the channel, done by interupt later.
 120:adc.c         **** 	_delay_loop_2(ADC_CYCLE_DELAY);
 121:adc.c         **** 	adc_set_channel(++curr_ch);
 122:adc.c         **** 	
 123:adc.c         **** 	// Wait for one set of convertions to complete.
 124:adc.c         **** 	//_delay_loop_2(ADC_CYCLE_DELAY*26);
 125:adc.c         **** 	#ifdef debug
 126:adc.c         **** 	fprintf_P(stderr,PSTR("\t[done]"));
 127:adc.c         **** 	#endif
 128:adc.c         **** }
 129:adc.c         **** 
 130:adc.c         **** void adc_set_channel(uint8_t channel) {
 237               	.LM11:
 238               	.LFBB5:
 239               	/* prologue: function */
 240               	/* frame size = 0 */
 131:adc.c         **** 	//Prescale reset on each "trigger event"s
 132:adc.c         **** 	//From Data Sheet: (Switching to Free Running mode (ADTS[2:0]=0) will)
 133:adc.c         **** 	//(not cause a trigger event, even if the ADC Interrupt Flag is set.)
 134:adc.c         **** 	ADMUX  = (uint8_t)((uint8_t)(ADMUX &0b11100000)|channels[channel]);
 242               	.LM12:
 243 0044 ACE7      		ldi r26,lo8(124)
 244 0046 B0E0      		ldi r27,hi8(124)
 245 0048 9C91      		ld r25,X
 246 004a E0E0      		ldi r30,lo8(channels)
 247 004c F0E0      		ldi r31,hi8(channels)
 248 004e E80F      		add r30,r24
 249 0050 F11D      		adc r31,__zero_reg__
 250 0052 907E      		andi r25,lo8(-32)
 251 0054 8081      		ld r24,Z
 252 0056 982B      		or r25,r24
 253 0058 9C93      		st X,r25
 254               	/* epilogue start */
 135:adc.c         **** 	//print_adc_values();
 136:adc.c         **** 	//printf("V - chan %X\n",channel);
 137:adc.c         **** }
 256               	.LM13:
 257 005a 0895      		ret
 259               	.Lscope5:
 261               		.stabd	78,0,0
 263               	.global	__vector_19
 265               	__vector_19:
 266               		.stabd	46,0,0
 138:adc.c         **** 
 139:adc.c         **** //ADC Interupt handler
 140:adc.c         **** ISR(ADC_vect) {
 268               	.LM14:
 269               	.LFBB6:
 270 005c 1F92      		push __zero_reg__
 271 005e 0F92      		push r0
 272 0060 0FB6      		in r0,__SREG__
 273 0062 0F92      		push r0
 274 0064 1124      		clr __zero_reg__
 275 0066 2F93      		push r18
 276 0068 3F93      		push r19
 277 006a 4F93      		push r20
 278 006c 8F93      		push r24
 279 006e 9F93      		push r25
 280 0070 AF93      		push r26
 281 0072 BF93      		push r27
 282 0074 EF93      		push r30
 283 0076 FF93      		push r31
 284               	/* prologue: Signal */
 285               	/* frame size = 0 */
 141:adc.c         **** 	// New conversion has already started.
 142:adc.c         **** 	uint16_t adc_value;
 143:adc.c         **** 	adc_value  =  ADCL;  
 287               	.LM15:
 288 0078 4091 7800 		lds r20,120
 144:adc.c         **** 	adc_value += (ADCH<<8);
 290               	.LM16:
 291 007c 3091 7900 		lds r19,121
 145:adc.c         **** 	uint8_t real_channel;
 146:adc.c         **** 	static uint8_t ct;
 147:adc.c         **** 	++ct;
 293               	.LM17:
 294 0080 8091 0000 		lds r24,ct.1880
 295 0084 8F5F      		subi r24,lo8(-(1))
 296 0086 8093 0000 		sts ct.1880,r24
 148:adc.c         **** 
 149:adc.c         **** 	// the curr_ch now has the chan of the on going conversion, we need the last one
 150:adc.c         **** 	if (curr_ch==0)	real_channel = channel_amt-1; //curr_ch==0 
 298               	.LM18:
 299 008a 2091 0000 		lds r18,curr_ch
 300 008e 2223      		tst r18
 301 0090 01F4      		brne .L13
 302 0092 E3E0      		ldi r30,lo8(3)
 303 0094 00C0      		rjmp .L14
 304               	.L13:
 151:adc.c         **** 	else		real_channel = curr_ch-1;
 306               	.LM19:
 307 0096 E22F      		mov r30,r18
 308 0098 E150      		subi r30,lo8(-(-1))
 309               	.L14:
 152:adc.c         **** 
 153:adc.c         **** 	adc_val[real_channel] = adc_value;
 311               	.LM20:
 312 009a F0E0      		ldi r31,lo8(0)
 313 009c EE0F      		lsl r30
 314 009e FF1F      		rol r31
 315 00a0 DF01      		movw r26,r30
 316 00a2 A050      		subi r26,lo8(-(adc_val))
 317 00a4 B040      		sbci r27,hi8(-(adc_val))
 318 00a6 932F      		mov r25,r19
 319 00a8 80E0      		ldi r24,lo8(0)
 320 00aa 840F      		add r24,r20
 321 00ac 911D      		adc r25,__zero_reg__
 322 00ae 8D93      		st X+,r24
 323 00b0 9C93      		st X,r25
 154:adc.c         **** 	++adc_amt[real_channel];
 325               	.LM21:
 326 00b2 E050      		subi r30,lo8(-(adc_amt))
 327 00b4 F040      		sbci r31,hi8(-(adc_amt))
 328 00b6 8081      		ld r24,Z
 329 00b8 9181      		ldd r25,Z+1
 330 00ba 0196      		adiw r24,1
 331 00bc 9183      		std Z+1,r25
 332 00be 8083      		st Z,r24
 155:adc.c         **** 
 156:adc.c         **** 	// Change the channel for the conversion after the one currently processing.
 157:adc.c         **** 	if (++curr_ch >= channel_amt)	curr_ch = 0;
 334               	.LM22:
 335 00c0 822F      		mov r24,r18
 336 00c2 8F5F      		subi r24,lo8(-(1))
 337 00c4 8093 0000 		sts curr_ch,r24
 338 00c8 8430      		cpi r24,lo8(4)
 339 00ca 00F0      		brlo .L15
 340 00cc 1092 0000 		sts curr_ch,__zero_reg__
 341               	.L15:
 342               	.LBB19:
 343               	.LBB20:
 345               	.LM23:
 346 00d0 8091 7C00 		lds r24,124
 347 00d4 E091 0000 		lds r30,curr_ch
 348 00d8 F0E0      		ldi r31,lo8(0)
 349 00da E050      		subi r30,lo8(-(channels))
 350 00dc F040      		sbci r31,hi8(-(channels))
 351 00de 807E      		andi r24,lo8(-32)
 352 00e0 9081      		ld r25,Z
 353 00e2 892B      		or r24,r25
 354 00e4 8093 7C00 		sts 124,r24
 355               	/* epilogue start */
 356               	.LBE20:
 357               	.LBE19:
 158:adc.c         **** 	
 159:adc.c         **** 	//Wait for the clock to be set, 1 adc cycle.
 160:adc.c         **** 	//_delay_loop2(ADC_CYCLE_DELAY);
 161:adc.c         **** 	adc_set_channel(curr_ch);
 162:adc.c         **** 	
 163:adc.c         **** 	//printf("adc_value: %d",adc_value);
 164:adc.c         **** 	
 165:adc.c         **** 	//TODO: modify for running average (Ave= (Ave*(ct-1)+New)/ct)
 166:adc.c         **** 	//INFO: Vin[V]=(ADCH256+ADCL)Vref[V]/1024
 167:adc.c         **** 	
 168:adc.c         **** 	if (!(ct%4)) {
 169:adc.c         **** 		//all values have been recalculated, update motors.
 170:adc.c         **** 	}
 171:adc.c         **** }
 359               	.LM24:
 360 00e8 FF91      		pop r31
 361 00ea EF91      		pop r30
 362 00ec BF91      		pop r27
 363 00ee AF91      		pop r26
 364 00f0 9F91      		pop r25
 365 00f2 8F91      		pop r24
 366 00f4 4F91      		pop r20
 367 00f6 3F91      		pop r19
 368 00f8 2F91      		pop r18
 369 00fa 0F90      		pop r0
 370 00fc 0FBE      		out __SREG__,r0
 371 00fe 0F90      		pop r0
 372 0100 1F90      		pop __zero_reg__
 373 0102 1895      		reti
 379               	.Lscope6:
 381               		.stabd	78,0,0
 383               	.global	adc_init
 385               	adc_init:
 386               		.stabd	46,0,0
 388               	.LM25:
 389               	.LFBB7:
 390 0104 EF92      		push r14
 391 0106 FF92      		push r15
 392 0108 0F93      		push r16
 393 010a 1F93      		push r17
 394               	/* prologue: function */
 395               	/* frame size = 0 */
 397               	.LM26:
 398 010c 80E0      		ldi r24,lo8(__c.1820)
 399 010e 90E0      		ldi r25,hi8(__c.1820)
 400 0110 9F93      		push r25
 401 0112 8F93      		push r24
 402 0114 8091 0000 		lds r24,__iob+4
 403 0118 9091 0000 		lds r25,(__iob+4)+1
 404 011c 9F93      		push r25
 405 011e 8F93      		push r24
 406 0120 0E94 0000 		call fprintf_P
 408               	.LM27:
 409 0124 E4E6      		ldi r30,lo8(100)
 410 0126 F0E0      		ldi r31,hi8(100)
 411 0128 8081      		ld r24,Z
 412 012a 8E7F      		andi r24,lo8(-2)
 413 012c 8083      		st Z,r24
 415               	.LM28:
 416 012e 0CE7      		ldi r16,lo8(124)
 417 0130 10E0      		ldi r17,hi8(124)
 418 0132 F801      		movw r30,r16
 419 0134 8081      		ld r24,Z
 420 0136 8064      		ori r24,lo8(64)
 421 0138 8083      		st Z,r24
 423               	.LM29:
 424 013a 8081      		ld r24,Z
 425 013c 8F77      		andi r24,lo8(127)
 426 013e 8083      		st Z,r24
 428               	.LM30:
 429 0140 2AE7      		ldi r18,lo8(122)
 430 0142 E22E      		mov r14,r18
 431 0144 F12C      		mov r15,__zero_reg__
 432 0146 F701      		movw r30,r14
 433 0148 8081      		ld r24,Z
 434 014a 886A      		ori r24,lo8(-88)
 435 014c 8083      		st Z,r24
 437               	.LM31:
 438 014e 8081      		ld r24,Z
 439 0150 887F      		andi r24,lo8(-8)
 440 0152 8660      		ori r24,lo8(6)
 441 0154 8083      		st Z,r24
 443               	.LM32:
 444 0156 EBE7      		ldi r30,lo8(123)
 445 0158 F0E0      		ldi r31,hi8(123)
 446 015a 8081      		ld r24,Z
 447 015c 8068      		ori r24,lo8(-128)
 448 015e 8083      		st Z,r24
 450               	.LM33:
 451 0160 8081      		ld r24,Z
 452 0162 887F      		andi r24,lo8(-8)
 453 0164 8083      		st Z,r24
 455               	.LM34:
 456 0166 EEE7      		ldi r30,lo8(126)
 457 0168 F0E0      		ldi r31,hi8(126)
 458 016a 8081      		ld r24,Z
 459 016c 806F      		ori r24,lo8(-16)
 460 016e 8083      		st Z,r24
 462               	.LM35:
 463 0170 83B7      		in r24,83-0x20
 464 0172 817F      		andi r24,lo8(-15)
 465 0174 8260      		ori r24,lo8(2)
 466 0176 83BF      		out 83-0x20,r24
 468               	.LM36:
 469 0178 80E0      		ldi r24,lo8(__c.1822)
 470 017a 90E0      		ldi r25,hi8(__c.1822)
 471 017c 9F93      		push r25
 472 017e 8F93      		push r24
 473 0180 8091 0000 		lds r24,__iob+4
 474 0184 9091 0000 		lds r25,(__iob+4)+1
 475 0188 9F93      		push r25
 476 018a 8F93      		push r24
 477 018c 0E94 0000 		call fprintf_P
 479               	.LM37:
 480 0190 2091 0000 		lds r18,curr_ch
 481               	.LBB21:
 482               	.LBB22:
 484               	.LM38:
 485 0194 F801      		movw r30,r16
 486 0196 8081      		ld r24,Z
 487 0198 A0E0      		ldi r26,lo8(channels)
 488 019a B0E0      		ldi r27,hi8(channels)
 489 019c FD01      		movw r30,r26
 490 019e E20F      		add r30,r18
 491 01a0 F11D      		adc r31,__zero_reg__
 492 01a2 807E      		andi r24,lo8(-32)
 493 01a4 9081      		ld r25,Z
 494 01a6 892B      		or r24,r25
 495 01a8 F801      		movw r30,r16
 496 01aa 8083      		st Z,r24
 497               	.LBE22:
 498               	.LBE21:
 500               	.LM39:
 501 01ac F701      		movw r30,r14
 502 01ae 8081      		ld r24,Z
 503 01b0 8064      		ori r24,lo8(64)
 504 01b2 8083      		st Z,r24
 505               	.LBB23:
 506               	.LBB24:
 508               	.Ltext3:
   1:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****    Copyright (c) 2007 Joerg Wunsch
   3:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****    All rights reserved.
   4:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h **** 
   5:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****    Redistribution and use in source and binary forms, with or without
   6:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****    modification, are permitted provided that the following conditions are met:
   7:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h **** 
   8:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****    * Redistributions of source code must retain the above copyright
   9:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****      notice, this list of conditions and the following disclaimer.
  10:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h **** 
  11:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****    * Redistributions in binary form must reproduce the above copyright
  12:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****      notice, this list of conditions and the following disclaimer in
  13:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****      the documentation and/or other materials provided with the
  14:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****      distribution.
  15:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h **** 
  16:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****    * Neither the name of the copyright holders nor the names of
  17:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****      contributors may be used to endorse or promote products derived
  18:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****      from this software without specific prior written permission.
  19:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h **** 
  20:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h **** 
  32:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h **** /* $Id: delay_basic.h,v 1.1 2007/05/13 21:23:20 joerg_wunsch Exp $ */
  33:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h **** 
  34:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h **** #ifndef _UTIL_DELAY_BASIC_H_
  35:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h **** #define _UTIL_DELAY_BASIC_H_ 1
  36:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h **** 
  37:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h **** #include <inttypes.h>
  38:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h **** 
  39:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h **** /** \file */
  40:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h **** /** \defgroup util_delay_basic <util/delay_basic.h>: Basic busy-wait delay loops
  41:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****     \code
  42:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****     #include <util/delay_basic.h>
  43:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****     \endcode
  44:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h **** 
  45:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****     The functions in this header file implement simple delay loops
  46:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****     that perform a busy-waiting.  They are typically used to
  47:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****     facilitate short delays in the program execution.  They are
  48:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****     implemented as count-down loops with a well-known CPU cycle
  49:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****     count per loop iteration.  As such, no other processing can
  50:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****     occur simultaneously.  It should be kept in mind that the
  51:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****     functions described here do not disable interrupts.
  52:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h **** 
  53:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****     In general, for long delays, the use of hardware timers is
  54:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****     much preferrable, as they free the CPU, and allow for
  55:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****     concurrent processing of other events while the timer is
  56:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****     running.  However, in particular for very short delays, the
  57:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****     overhead of setting up a hardware timer is too much compared
  58:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****     to the overall delay time.
  59:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h **** 
  60:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****     Two inline functions are provided for the actual delay algorithms.
  61:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h **** 
  62:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h **** */
  63:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h **** 
  64:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h **** #if !defined(__DOXYGEN__)
  65:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h **** static inline void _delay_loop_1(uint8_t __count) __attribute__((always_inline));
  66:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h **** static inline void _delay_loop_2(uint16_t __count) __attribute__((always_inline));
  67:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h **** #endif
  68:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h **** 
  69:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h **** /** \ingroup util_delay_basic
  70:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h **** 
  71:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****     Delay loop using an 8-bit counter \c __count, so up to 256
  72:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****     iterations are possible.  (The value 256 would have to be passed
  73:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****     as 0.)  The loop executes three CPU cycles per iteration, not
  74:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****     including the overhead the compiler needs to setup the counter
  75:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****     register.
  76:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h **** 
  77:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to 768 microseconds
  78:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****     can be achieved.
  79:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h **** */
  80:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h **** void
  81:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h **** _delay_loop_1(uint8_t __count)
  82:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h **** {
  83:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h **** 	__asm__ volatile (
  84:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h **** 		"1: dec %0" "\n\t"
  85:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h **** 		"brne 1b"
  86:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h **** 		: "=r" (__count)
  87:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h **** 		: "0" (__count)
  88:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h **** 	);
  89:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h **** }
  90:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h **** 
  91:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h **** /** \ingroup util_delay_basic
  92:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h **** 
  93:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****     Delay loop using a 16-bit counter \c __count, so up to 65536
  94:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****     iterations are possible.  (The value 65536 would have to be
  95:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****     passed as 0.)  The loop executes four CPU cycles per iteration,
  96:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****     not including the overhead the compiler requires to setup the
  97:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****     counter register pair.
  98:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h **** 
  99:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to about 262.1
 100:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****     milliseconds can be achieved.
 101:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****  */
 102:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h **** void
 103:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h **** _delay_loop_2(uint16_t __count)
 104:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h **** {
 105:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h **** 	__asm__ volatile (
 510               	.LM40:
 511 01b4 80E0      		ldi r24,lo8(0)
 512 01b6 90E0      		ldi r25,hi8(0)
 513               	/* #APP */
 514               	 ;  105 "/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h" 1
 515 01b8 0197      		1: sbiw r24,1
 516 01ba 01F4      		brne 1b
 517               	 ;  0 "" 2
 518               	/* #NOAPP */
 519               	.LBE24:
 520               	.LBE23:
 522               	.Ltext4:
 524               	.LM41:
 525 01bc 2F5F      		subi r18,lo8(-(1))
 526 01be 2093 0000 		sts curr_ch,r18
 527               	.LBB25:
 528               	.LBB26:
 530               	.LM42:
 531 01c2 F801      		movw r30,r16
 532 01c4 8081      		ld r24,Z
 533 01c6 A20F      		add r26,r18
 534 01c8 B11D      		adc r27,__zero_reg__
 535 01ca 807E      		andi r24,lo8(-32)
 536 01cc 9C91      		ld r25,X
 537 01ce 892B      		or r24,r25
 538 01d0 8083      		st Z,r24
 539               	.LBE26:
 540               	.LBE25:
 542               	.LM43:
 543 01d2 80E0      		ldi r24,lo8(__c.1824)
 544 01d4 90E0      		ldi r25,hi8(__c.1824)
 545 01d6 9F93      		push r25
 546 01d8 8F93      		push r24
 547 01da 8091 0000 		lds r24,__iob+4
 548 01de 9091 0000 		lds r25,(__iob+4)+1
 549 01e2 9F93      		push r25
 550 01e4 8F93      		push r24
 551 01e6 0E94 0000 		call fprintf_P
 552 01ea 8DB7      		in r24,__SP_L__
 553 01ec 9EB7      		in r25,__SP_H__
 554 01ee 0C96      		adiw r24,12
 555 01f0 0FB6      		in __tmp_reg__,__SREG__
 556 01f2 F894      		cli
 557 01f4 9EBF      		out __SP_H__,r25
 558 01f6 0FBE      		out __SREG__,__tmp_reg__
 559 01f8 8DBF      		out __SP_L__,r24
 560               	/* epilogue start */
 562               	.LM44:
 563 01fa 1F91      		pop r17
 564 01fc 0F91      		pop r16
 565 01fe FF90      		pop r15
 566 0200 EF90      		pop r14
 567 0202 0895      		ret
 572               	.Lscope7:
 574               		.stabd	78,0,0
 576               	.global	adc_calibrate_store
 578               	adc_calibrate_store:
 579               		.stabd	46,0,0
 581               	.LM45:
 582               	.LFBB8:
 583               	/* prologue: function */
 584               	/* frame size = 0 */
 586               	.LM46:
 587 0204 80E0      		ldi r24,lo8(__c.1813)
 588 0206 90E0      		ldi r25,hi8(__c.1813)
 589 0208 9F93      		push r25
 590 020a 8F93      		push r24
 591 020c 8091 0000 		lds r24,__iob+4
 592 0210 9091 0000 		lds r25,(__iob+4)+1
 593 0214 9F93      		push r25
 594 0216 8F93      		push r24
 595 0218 0E94 0000 		call fprintf_P
 596 021c 0F90      		pop __tmp_reg__
 597 021e 0F90      		pop __tmp_reg__
 598 0220 0F90      		pop __tmp_reg__
 599 0222 0F90      		pop __tmp_reg__
 600               	/* epilogue start */
 602               	.LM47:
 603 0224 0895      		ret
 605               	.Lscope8:
 607               		.stabd	78,0,0
 609               	.global	adc_calibrate_clear
 611               	adc_calibrate_clear:
 612               		.stabd	46,0,0
 614               	.LM48:
 615               	.LFBB9:
 616               	/* prologue: function */
 617               	/* frame size = 0 */
 619               	.LM49:
 620 0226 88E0      		ldi r24,lo8(8)
 621 0228 E0E0      		ldi r30,lo8(adc_offset)
 622 022a F0E0      		ldi r31,hi8(adc_offset)
 623 022c DF01      		movw r26,r30
 624 022e 1D92      		st X+,__zero_reg__
 625 0230 8A95      	        dec r24
 626 0232 01F4      		brne .-6
 628               	.LM50:
 629 0234 1092 0000 		sts num_calibrations,__zero_reg__
 630               	/* epilogue start */
 632               	.LM51:
 633 0238 0895      		ret
 635               	.Lscope9:
 637               		.stabd	78,0,0
 639               	.global	adc_calibrate_update
 641               	adc_calibrate_update:
 642               		.stabd	46,0,0
 644               	.LM52:
 645               	.LFBB10:
 646 023a CF92      		push r12
 647 023c DF92      		push r13
 648 023e EF92      		push r14
 649 0240 FF92      		push r15
 650 0242 0F93      		push r16
 651 0244 1F93      		push r17
 652 0246 DF93      		push r29
 653 0248 CF93      		push r28
 654 024a CDB7      		in r28,__SP_L__
 655 024c DEB7      		in r29,__SP_H__
 656 024e 6097      		sbiw r28,16
 657 0250 0FB6      		in __tmp_reg__,__SREG__
 658 0252 F894      		cli
 659 0254 DEBF      		out __SP_H__,r29
 660 0256 0FBE      		out __SREG__,__tmp_reg__
 661 0258 CDBF      		out __SP_L__,r28
 662               	/* prologue: function */
 663               	/* frame size = 16 */
 665               	.LM53:
 666 025a DE01      		movw r26,r28
 667 025c 1996      		adiw r26,9
 668 025e E0E0      		ldi r30,lo8(adc_val)
 669 0260 F0E0      		ldi r31,hi8(adc_val)
 670 0262 88E0      		ldi r24,lo8(8)
 671               	.L24:
 672 0264 0190      		ld r0,Z+
 673 0266 0D92      		st X+,r0
 674 0268 8150      		subi r24,lo8(-(-1))
 675 026a 01F4      		brne .L24
 676               	.LBB27:
 678               	.LM54:
 679 026c 4985      		ldd r20,Y+9
 680 026e 5A85      		ldd r21,Y+10
 681 0270 20E0      		ldi r18,lo8(0)
 682 0272 30E0      		ldi r19,hi8(0)
 683 0274 8E01      		movw r16,r28
 684 0276 0F5F      		subi r16,lo8(-(1))
 685 0278 1F4F      		sbci r17,hi8(-(1))
 686 027a BE01      		movw r22,r28
 687 027c 675F      		subi r22,lo8(-(9))
 688 027e 7F4F      		sbci r23,hi8(-(9))
 689               	.L25:
 690 0280 D801      		movw r26,r16
 691 0282 A20F      		add r26,r18
 692 0284 B31F      		adc r27,r19
 693 0286 FB01      		movw r30,r22
 694 0288 E20F      		add r30,r18
 695 028a F31F      		adc r31,r19
 696 028c 8081      		ld r24,Z
 697 028e 9181      		ldd r25,Z+1
 698 0290 FA01      		movw r30,r20
 699 0292 E81B      		sub r30,r24
 700 0294 F90B      		sbc r31,r25
 701 0296 ED93      		st X+,r30
 702 0298 FC93      		st X,r31
 703 029a 2E5F      		subi r18,lo8(-(2))
 704 029c 3F4F      		sbci r19,hi8(-(2))
 706               	.LM55:
 707 029e 2830      		cpi r18,8
 708 02a0 3105      		cpc r19,__zero_reg__
 709 02a2 01F4      		brne .L25
 710               	.LBE27:
 712               	.LM56:
 713 02a4 8091 0000 		lds r24,num_calibrations
 714 02a8 9E01      		movw r18,r28
 715 02aa 2F5F      		subi r18,lo8(-(1))
 716 02ac 3F4F      		sbci r19,hi8(-(1))
 717 02ae 8823      		tst r24
 718 02b0 01F4      		brne .L26
 720               	.LM57:
 721 02b2 A0E0      		ldi r26,lo8(adc_offset)
 722 02b4 B0E0      		ldi r27,hi8(adc_offset)
 723 02b6 F901      		movw r30,r18
 724 02b8 88E0      		ldi r24,lo8(8)
 725               	.L27:
 726 02ba 0190      		ld r0,Z+
 727 02bc 0D92      		st X+,r0
 728 02be 8150      		subi r24,lo8(-(-1))
 729 02c0 01F4      		brne .L27
 730 02c2 00C0      		rjmp .L28
 731               	.L26:
 732 02c4 E0E0      		ldi r30,lo8(adc_offset)
 733 02c6 F0E0      		ldi r31,hi8(adc_offset)
 734 02c8 7901      		movw r14,r18
 735               	.LBB28:
 737               	.LM58:
 738 02ca 082F      		mov r16,r24
 739 02cc 10E0      		ldi r17,lo8(0)
 740 02ce 6801      		movw r12,r16
 741 02d0 0894      		sec
 742 02d2 C11C      		adc r12,__zero_reg__
 743 02d4 D11C      		adc r13,__zero_reg__
 744               	.L29:
 745 02d6 8081      		ld r24,Z
 746 02d8 9181      		ldd r25,Z+1
 747 02da 9C01      		movw r18,r24
 748 02dc 029F      		mul r16,r18
 749 02de C001      		movw r24,r0
 750 02e0 039F      		mul r16,r19
 751 02e2 900D      		add r25,r0
 752 02e4 129F      		mul r17,r18
 753 02e6 900D      		add r25,r0
 754 02e8 1124      		clr r1
 755 02ea D701      		movw r26,r14
 756 02ec 2D91      		ld r18,X+
 757 02ee 3D91      		ld r19,X+
 758 02f0 7D01      		movw r14,r26
 759 02f2 820F      		add r24,r18
 760 02f4 931F      		adc r25,r19
 761 02f6 B601      		movw r22,r12
 762 02f8 0E94 0000 		call __divmodhi4
 763 02fc 6193      		st Z+,r22
 764 02fe 7193      		st Z+,r23
 766               	.LM59:
 767 0300 B0E0      		ldi r27,hi8(adc_offset+8)
 768 0302 E030      		cpi r30,lo8(adc_offset+8)
 769 0304 FB07      		cpc r31,r27
 770 0306 01F4      		brne .L29
 771               	.L28:
 772               	.LBE28:
 774               	.LM60:
 775 0308 8091 0000 		lds r24,num_calibrations
 776 030c 8F5F      		subi r24,lo8(-(1))
 777 030e 8093 0000 		sts num_calibrations,r24
 778               	/* epilogue start */
 780               	.LM61:
 781 0312 6096      		adiw r28,16
 782 0314 0FB6      		in __tmp_reg__,__SREG__
 783 0316 F894      		cli
 784 0318 DEBF      		out __SP_H__,r29
 785 031a 0FBE      		out __SREG__,__tmp_reg__
 786 031c CDBF      		out __SP_L__,r28
 787 031e CF91      		pop r28
 788 0320 DF91      		pop r29
 789 0322 1F91      		pop r17
 790 0324 0F91      		pop r16
 791 0326 FF90      		pop r15
 792 0328 EF90      		pop r14
 793 032a DF90      		pop r13
 794 032c CF90      		pop r12
 795 032e 0895      		ret
 801               	.Lscope10:
 803               		.stabd	78,0,0
 804               		.data
 805               	.LC0:
 806 0000 205B 2025 		.string	" [ %d : %d ] "
 806      6420 3A20 
 806      2564 205D 
 806      2000 
 807               		.text
 809               	.global	print_adc_calibration
 811               	print_adc_calibration:
 812               		.stabd	46,0,0
 814               	.LM62:
 815               	.LFBB11:
 816 0330 0F93      		push r16
 817 0332 1F93      		push r17
 818               	/* prologue: function */
 819               	/* frame size = 0 */
 821               	.LM63:
 822 0334 80E0      		ldi r24,lo8(__c.1756)
 823 0336 90E0      		ldi r25,hi8(__c.1756)
 824 0338 9F93      		push r25
 825 033a 8F93      		push r24
 826 033c 8091 0000 		lds r24,__iob+4
 827 0340 9091 0000 		lds r25,(__iob+4)+1
 828 0344 9F93      		push r25
 829 0346 8F93      		push r24
 830 0348 0E94 0000 		call fprintf_P
 831               	.LBB29:
 833               	.LM64:
 834 034c 8091 0000 		lds r24,adc_offset
 835 0350 9091 0000 		lds r25,(adc_offset)+1
 836 0354 9F93      		push r25
 837 0356 8F93      		push r24
 838 0358 1F92      		push __zero_reg__
 839 035a 1F92      		push __zero_reg__
 840 035c 00E0      		ldi r16,lo8(.LC0)
 841 035e 10E0      		ldi r17,hi8(.LC0)
 842 0360 1F93      		push r17
 843 0362 0F93      		push r16
 844 0364 8091 0000 		lds r24,__iob+4
 845 0368 9091 0000 		lds r25,(__iob+4)+1
 846 036c 9F93      		push r25
 847 036e 8F93      		push r24
 848 0370 0E94 0000 		call fprintf
 849 0374 8091 0000 		lds r24,adc_offset+2
 850 0378 9091 0000 		lds r25,(adc_offset+2)+1
 851 037c 9F93      		push r25
 852 037e 8F93      		push r24
 853 0380 81E0      		ldi r24,lo8(1)
 854 0382 90E0      		ldi r25,hi8(1)
 855 0384 9F93      		push r25
 856 0386 8F93      		push r24
 857 0388 1F93      		push r17
 858 038a 0F93      		push r16
 859 038c 8091 0000 		lds r24,__iob+4
 860 0390 9091 0000 		lds r25,(__iob+4)+1
 861 0394 9F93      		push r25
 862 0396 8F93      		push r24
 863 0398 0E94 0000 		call fprintf
 864 039c 8091 0000 		lds r24,adc_offset+4
 865 03a0 9091 0000 		lds r25,(adc_offset+4)+1
 866 03a4 9F93      		push r25
 867 03a6 8F93      		push r24
 868 03a8 82E0      		ldi r24,lo8(2)
 869 03aa 90E0      		ldi r25,hi8(2)
 870 03ac 9F93      		push r25
 871 03ae 8F93      		push r24
 872 03b0 1F93      		push r17
 873 03b2 0F93      		push r16
 874 03b4 8091 0000 		lds r24,__iob+4
 875 03b8 9091 0000 		lds r25,(__iob+4)+1
 876 03bc 9F93      		push r25
 877 03be 8F93      		push r24
 878 03c0 0E94 0000 		call fprintf
 879 03c4 8091 0000 		lds r24,adc_offset+6
 880 03c8 9091 0000 		lds r25,(adc_offset+6)+1
 881 03cc 9F93      		push r25
 882 03ce 8F93      		push r24
 883 03d0 83E0      		ldi r24,lo8(3)
 884 03d2 90E0      		ldi r25,hi8(3)
 885 03d4 9F93      		push r25
 886 03d6 8F93      		push r24
 887 03d8 1F93      		push r17
 888 03da 0F93      		push r16
 889 03dc 8091 0000 		lds r24,__iob+4
 890 03e0 9091 0000 		lds r25,(__iob+4)+1
 891 03e4 9F93      		push r25
 892 03e6 8F93      		push r24
 893 03e8 0E94 0000 		call fprintf
 894 03ec 8DB7      		in r24,__SP_L__
 895 03ee 9EB7      		in r25,__SP_H__
 896 03f0 8496      		adiw r24,36
 897 03f2 0FB6      		in __tmp_reg__,__SREG__
 898 03f4 F894      		cli
 899 03f6 9EBF      		out __SP_H__,r25
 900 03f8 0FBE      		out __SREG__,__tmp_reg__
 901 03fa 8DBF      		out __SP_L__,r24
 902               	/* epilogue start */
 903               	.LBE29:
 905               	.LM65:
 906 03fc 1F91      		pop r17
 907 03fe 0F91      		pop r16
 908 0400 0895      		ret
 910               	.Lscope11:
 912               		.stabd	78,0,0
 914               	.global	print_adc_values
 916               	print_adc_values:
 917               		.stabd	46,0,0
 919               	.LM66:
 920               	.LFBB12:
 921 0402 CF92      		push r12
 922 0404 DF92      		push r13
 923 0406 EF92      		push r14
 924 0408 FF92      		push r15
 925 040a 0F93      		push r16
 926 040c 1F93      		push r17
 927 040e CF93      		push r28
 928 0410 DF93      		push r29
 929               	/* prologue: function */
 930               	/* frame size = 0 */
 932               	.LM67:
 933 0412 80E0      		ldi r24,lo8(__c.1737)
 934 0414 90E0      		ldi r25,hi8(__c.1737)
 935 0416 9F93      		push r25
 936 0418 8F93      		push r24
 937 041a 8091 0000 		lds r24,__iob+4
 938 041e 9091 0000 		lds r25,(__iob+4)+1
 939 0422 9F93      		push r25
 940 0424 8F93      		push r24
 941 0426 0E94 0000 		call fprintf_P
 942               	.LBB30:
 944               	.LM68:
 945 042a 8091 0000 		lds r24,adc_val
 946 042e 9091 0000 		lds r25,(adc_val)+1
 947 0432 9F93      		push r25
 948 0434 8F93      		push r24
 949 0436 1F92      		push __zero_reg__
 950 0438 1F92      		push __zero_reg__
 951 043a 00E0      		ldi r16,lo8(.LC0)
 952 043c 10E0      		ldi r17,hi8(.LC0)
 953 043e 1F93      		push r17
 954 0440 0F93      		push r16
 955 0442 8091 0000 		lds r24,__iob+4
 956 0446 9091 0000 		lds r25,(__iob+4)+1
 957 044a 9F93      		push r25
 958 044c 8F93      		push r24
 959 044e 0E94 0000 		call fprintf
 960 0452 8091 0000 		lds r24,adc_val+2
 961 0456 9091 0000 		lds r25,(adc_val+2)+1
 962 045a 9F93      		push r25
 963 045c 8F93      		push r24
 964 045e 81E0      		ldi r24,lo8(1)
 965 0460 90E0      		ldi r25,hi8(1)
 966 0462 9F93      		push r25
 967 0464 8F93      		push r24
 968 0466 1F93      		push r17
 969 0468 0F93      		push r16
 970 046a 8091 0000 		lds r24,__iob+4
 971 046e 9091 0000 		lds r25,(__iob+4)+1
 972 0472 9F93      		push r25
 973 0474 8F93      		push r24
 974 0476 0E94 0000 		call fprintf
 975 047a 8091 0000 		lds r24,adc_val+4
 976 047e 9091 0000 		lds r25,(adc_val+4)+1
 977 0482 9F93      		push r25
 978 0484 8F93      		push r24
 979 0486 82E0      		ldi r24,lo8(2)
 980 0488 90E0      		ldi r25,hi8(2)
 981 048a 9F93      		push r25
 982 048c 8F93      		push r24
 983 048e 1F93      		push r17
 984 0490 0F93      		push r16
 985 0492 8091 0000 		lds r24,__iob+4
 986 0496 9091 0000 		lds r25,(__iob+4)+1
 987 049a 9F93      		push r25
 988 049c 8F93      		push r24
 989 049e 0E94 0000 		call fprintf
 990 04a2 8091 0000 		lds r24,adc_val+6
 991 04a6 9091 0000 		lds r25,(adc_val+6)+1
 992 04aa 9F93      		push r25
 993 04ac 8F93      		push r24
 994 04ae 83E0      		ldi r24,lo8(3)
 995 04b0 90E0      		ldi r25,hi8(3)
 996 04b2 9F93      		push r25
 997 04b4 8F93      		push r24
 998 04b6 1F93      		push r17
 999 04b8 0F93      		push r16
 1000 04ba 8091 0000 		lds r24,__iob+4
 1001 04be 9091 0000 		lds r25,(__iob+4)+1
 1002 04c2 9F93      		push r25
 1003 04c4 8F93      		push r24
 1004 04c6 0E94 0000 		call fprintf
 1005               	.LBE30:
 1007               	.LM69:
 1008 04ca 8DB7      		in r24,__SP_L__
 1009 04cc 9EB7      		in r25,__SP_H__
 1010 04ce 8496      		adiw r24,36
 1011 04d0 0FB6      		in __tmp_reg__,__SREG__
 1012 04d2 F894      		cli
 1013 04d4 9EBF      		out __SP_H__,r25
 1014 04d6 0FBE      		out __SREG__,__tmp_reg__
 1015 04d8 8DBF      		out __SP_L__,r24
 1016 04da 80E0      		ldi r24,lo8(__c.1743)
 1017 04dc 90E0      		ldi r25,hi8(__c.1743)
 1018 04de 9F93      		push r25
 1019 04e0 8F93      		push r24
 1020 04e2 8091 0000 		lds r24,__iob+4
 1021 04e6 9091 0000 		lds r25,(__iob+4)+1
 1022 04ea 9F93      		push r25
 1023 04ec 8F93      		push r24
 1024 04ee 0E94 0000 		call fprintf_P
 1025 04f2 40E0      		ldi r20,lo8(adc_val)
 1026 04f4 C42E      		mov r12,r20
 1027 04f6 40E0      		ldi r20,hi8(adc_val)
 1028 04f8 D42E      		mov r13,r20
 1029 04fa 30E0      		ldi r19,lo8(adc_offset)
 1030 04fc E32E      		mov r14,r19
 1031 04fe 30E0      		ldi r19,hi8(adc_offset)
 1032 0500 F32E      		mov r15,r19
 1033 0502 C0E0      		ldi r28,lo8(0)
 1034 0504 D0E0      		ldi r29,hi8(0)
 1035 0506 0F90      		pop __tmp_reg__
 1036 0508 0F90      		pop __tmp_reg__
 1037 050a 0F90      		pop __tmp_reg__
 1038 050c 0F90      		pop __tmp_reg__
 1039               	.L38:
 1040               	.LBB31:
 1042               	.LM70:
 1043 050e F701      		movw r30,r14
 1044 0510 8191      		ld r24,Z+
 1045 0512 9191      		ld r25,Z+
 1046 0514 7F01      		movw r14,r30
 1047 0516 F601      		movw r30,r12
 1048 0518 2191      		ld r18,Z+
 1049 051a 3191      		ld r19,Z+
 1050 051c 6F01      		movw r12,r30
 1051 051e 820F      		add r24,r18
 1052 0520 931F      		adc r25,r19
 1053 0522 9F93      		push r25
 1054 0524 8F93      		push r24
 1055 0526 DF93      		push r29
 1056 0528 CF93      		push r28
 1057 052a 1F93      		push r17
 1058 052c 0F93      		push r16
 1059 052e 8091 0000 		lds r24,__iob+4
 1060 0532 9091 0000 		lds r25,(__iob+4)+1
 1061 0536 9F93      		push r25
 1062 0538 8F93      		push r24
 1063 053a 0E94 0000 		call fprintf
 1064 053e 2196      		adiw r28,1
 1066               	.LM71:
 1067 0540 8DB7      		in r24,__SP_L__
 1068 0542 9EB7      		in r25,__SP_H__
 1069 0544 0896      		adiw r24,8
 1070 0546 0FB6      		in __tmp_reg__,__SREG__
 1071 0548 F894      		cli
 1072 054a 9EBF      		out __SP_H__,r25
 1073 054c 0FBE      		out __SREG__,__tmp_reg__
 1074 054e 8DBF      		out __SP_L__,r24
 1075 0550 C430      		cpi r28,4
 1076 0552 D105      		cpc r29,__zero_reg__
 1077 0554 01F4      		brne .L38
 1078               	/* epilogue start */
 1079               	.LBE31:
 1081               	.LM72:
 1082 0556 DF91      		pop r29
 1083 0558 CF91      		pop r28
 1084 055a 1F91      		pop r17
 1085 055c 0F91      		pop r16
 1086 055e FF90      		pop r15
 1087 0560 EF90      		pop r14
 1088 0562 DF90      		pop r13
 1089 0564 CF90      		pop r12
 1090 0566 0895      		ret
 1092               	.Lscope12:
 1094               		.stabd	78,0,0
 1095               		.lcomm ct.1880,1
 1096               		.data
 1099               	channels:
 1100 000e 04        		.byte	4
 1101 000f 06        		.byte	6
 1102 0010 05        		.byte	5
 1103 0011 07        		.byte	7
 1104               		.section	.progmem.data,"a",@progbits
 1107               	__c.1824:
 1108 0000 095B 646F 		.string	"\t[done]"
 1108      6E65 5D00 
 1111               	__c.1822:
 1112 0008 0A61 6463 		.string	"\nadc: init: setup convertions"
 1112      3A20 696E 
 1112      6974 3A20 
 1112      7365 7475 
 1112      7020 636F 
 1115               	__c.1820:
 1116 0026 0A61 6463 		.string	"\nadc: init"
 1116      3A20 696E 
 1116      6974 00
 1119               	__c.1813:
 1120 0031 0A5B 64   		.ascii	"\n[d"
 1121 0034 6562 7567 		.string	"ebug] Warning: unimplimented function adc_calibrate_store called"
 1121      5D20 5761 
 1121      726E 696E 
 1121      673A 2075 
 1121      6E69 6D70 
 1124               	__c.1756:
 1125 0075 0A5B 6465 		.string	"\n[debug] ADC OFFSETS: "
 1125      6275 675D 
 1125      2041 4443 
 1125      204F 4646 
 1125      5345 5453 
 1128               	__c.1743:
 1129 008c 0A5B 6465 		.string	"\n[debug] FIXED ADC: "
 1129      6275 675D 
 1129      2046 4958 
 1129      4544 2041 
 1129      4443 3A20 
 1132               	__c.1737:
 1133 00a1 0A5B 6465 		.string	"\n[debug]   RAW ADC: "
 1133      6275 675D 
 1133      2020 2052 
 1133      4157 2041 
 1133      4443 3A20 
 1134               		.lcomm num_calibrations,1
 1135               		.comm c_mode,1,1
 1136               		.comm initial,1,1
 1137               		.comm adc_val,8,1
 1138               		.comm adc_offset,8,1
 1139               		.comm adc_amt,8,1
 1140               		.comm curr_ch,1,1
 1157               		.text
 1159               	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 adc.c
     /tmp/ccS5Bj0p.s:2      *ABS*:0000003f __SREG__
     /tmp/ccS5Bj0p.s:3      *ABS*:0000003e __SP_H__
     /tmp/ccS5Bj0p.s:4      *ABS*:0000003d __SP_L__
     /tmp/ccS5Bj0p.s:5      *ABS*:00000000 __tmp_reg__
     /tmp/ccS5Bj0p.s:6      *ABS*:00000001 __zero_reg__
     /tmp/ccS5Bj0p.s:105    .text:00000000 copysign
     /tmp/ccS5Bj0p.s:134    .text:00000006 isfinite
     /tmp/ccS5Bj0p.s:175    .text:0000001e max
     /tmp/ccS5Bj0p.s:197    .text:00000022 adc_get_val
                            *COM*:00000008 adc_val
                            *COM*:00000008 adc_offset
     /tmp/ccS5Bj0p.s:234    .text:00000044 adc_set_channel
     /tmp/ccS5Bj0p.s:1099   .data:0000000e channels
     /tmp/ccS5Bj0p.s:265    .text:0000005c __vector_19
                             .bss:00000000 ct.1880
                            *COM*:00000001 curr_ch
                            *COM*:00000008 adc_amt
     /tmp/ccS5Bj0p.s:385    .text:00000104 adc_init
     /tmp/ccS5Bj0p.s:1115   .progmem.data:00000026 __c.1820
     /tmp/ccS5Bj0p.s:1111   .progmem.data:00000008 __c.1822
     /tmp/ccS5Bj0p.s:1107   .progmem.data:00000000 __c.1824
     /tmp/ccS5Bj0p.s:578    .text:00000204 adc_calibrate_store
     /tmp/ccS5Bj0p.s:1119   .progmem.data:00000031 __c.1813
     /tmp/ccS5Bj0p.s:611    .text:00000226 adc_calibrate_clear
     /tmp/ccS5Bj0p.s:1095   .bss:00000001 num_calibrations
     /tmp/ccS5Bj0p.s:641    .text:0000023a adc_calibrate_update
     /tmp/ccS5Bj0p.s:811    .text:00000330 print_adc_calibration
     /tmp/ccS5Bj0p.s:1124   .progmem.data:00000075 __c.1756
     /tmp/ccS5Bj0p.s:916    .text:00000402 print_adc_values
     /tmp/ccS5Bj0p.s:1132   .progmem.data:000000a1 __c.1737
     /tmp/ccS5Bj0p.s:1128   .progmem.data:0000008c __c.1743
                            *COM*:00000001 c_mode
                            *COM*:00000001 initial

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
__iob
fprintf_P
__divmodhi4
fprintf
