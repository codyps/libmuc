   1               		.file	"adc.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.global __do_copy_data
   8               		.global __do_clear_bss
  10               		.text
  11               	.Ltext0:
 102               	.global	copysign
 104               	copysign:
 106               	.Ltext1:
   1:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** /* Copyright (c) 2002,2007 Michael Stumpf
   2:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
   3:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****    Portions of documentation Copyright (c) 1990 - 1994
   4:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****    The Regents of the University of California.
   5:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
   6:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****    All rights reserved.
   7:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
   8:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****    Redistribution and use in source and binary forms, with or without
   9:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****    modification, are permitted provided that the following conditions are met:
  10:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
  11:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****    * Redistributions of source code must retain the above copyright
  12:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      notice, this list of conditions and the following disclaimer.
  13:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
  14:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****    * Redistributions in binary form must reproduce the above copyright
  15:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      notice, this list of conditions and the following disclaimer in
  16:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      the documentation and/or other materials provided with the
  17:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      distribution.
  18:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
  19:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****    * Neither the name of the copyright holders nor the names of
  20:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      contributors may be used to endorse or promote products derived
  21:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      from this software without specific prior written permission.
  22:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
  23:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  24:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  25:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  26:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  27:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  28:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  29:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  30:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  31:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  32:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  33:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   POSSIBILITY OF SUCH DAMAGE. */
  34:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
  35:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** /* $Id: math.h,v 1.21.2.1 2008/03/17 15:28:49 arcanum Exp $ */
  36:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
  37:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** /*
  38:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****    math.h - mathematical functions
  39:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
  40:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****    Author : Michael Stumpf
  41:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****             Michael.Stumpf@t-online.de
  42:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
  43:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****    __ATTR_CONST__ added by marekm@linux.org.pl for functions
  44:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****    that "do not examine any values except their arguments, and have
  45:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****    no effects except the return value", for better optimization by gcc.
  46:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****  */
  47:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
  48:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** #ifndef __MATH_H
  49:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** #define __MATH_H
  50:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
  51:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** /** \file */
  52:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** /** \defgroup avr_math <math.h>: Mathematics
  53:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****     \code #include <math.h> \endcode
  54:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
  55:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****     This header file declares basic mathematics constants and
  56:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****     functions.
  57:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
  58:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****     \par Notes:
  59:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****     - In order to access the functions delcared herein, it is usually
  60:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****       also required to additionally link against the library \c libm.a.
  61:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****       See also the related \ref faq_libm "FAQ entry".
  62:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****     - Math functions do not raise exceptions and do not change the
  63:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****       \c errno variable. Therefore the majority of them are declared
  64:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****       with const attribute, for better optimization by GCC.	*/
  65:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
  66:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** /**
  67:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****    \ingroup avr_math
  68:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
  69:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****    The constant \c pi. */
  70:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** #define M_PI 3.141592653589793238462643
  71:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
  72:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** /**
  73:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****    \ingroup avr_math
  74:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
  75:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****    The square root of 2. */
  76:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** #define M_SQRT2 1.4142135623730950488016887
  77:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
  78:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** /**
  79:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****    \ingroup avr_math
  80:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
  81:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****    NAN constant. */
  82:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** #define NAN	__builtin_nan("")
  83:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
  84:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** /**
  85:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****    \ingroup avr_math
  86:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
  87:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****    INFINITY constant. */
  88:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** #define INFINITY	__builtin_inf()
  89:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
  90:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** #ifndef __ATTR_CONST__
  91:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** # define __ATTR_CONST__ __attribute__((__const__))
  92:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** #endif
  93:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
  94:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** #ifdef __cplusplus
  95:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** extern "C" {
  96:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** #endif
  97:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
  98:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   /**
  99:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      \ingroup avr_math
 100:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 101:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      The cos() function returns the cosine of \a __x, measured in radians.
 102:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   */
 103:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** extern double cos(double __x) __ATTR_CONST__;
 104:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 105:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   /**
 106:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      \ingroup avr_math
 107:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 108:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      The fabs() function computes the absolute value of a floating-point
 109:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      number \a __x.
 110:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   */
 111:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** extern double fabs(double __x) __ATTR_CONST__;
 112:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** #if 0
 113:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** /* fabs seems to be built in already */
 114:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** extern inline double fabs( double __x )
 115:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   { double __res;
 116:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****     __asm__ __volatile__ ("andi %D0,0x7F \n\t"
 117:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 		: "=d" (__res) : "0" (__x) );
 118:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****     return __res;
 119:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   }
 120:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** #endif
 121:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 122:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   /**
 123:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      \ingroup avr_math
 124:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 125:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      The function fmod() returns the floating-point remainder of <em>__x /
 126:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      __y</em>.
 127:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   */
 128:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** extern double fmod(double __x, double __y) __ATTR_CONST__;
 129:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 130:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   /**
 131:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      \ingroup avr_math
 132:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 133:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      The modf() function breaks the argument \a __x into integral and
 134:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      fractional parts, each of which has the same sign as the argument. 
 135:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      It stores the integral part as a double in the object pointed to by
 136:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      \a __iptr.
 137:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 138:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      The modf() function returns the signed fractional part of \a __x.
 139:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      
 140:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      \note
 141:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      This implementation skips writing by zero pointer.
 142:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   */
 143:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** extern double modf(double __x, double *__iptr);
 144:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 145:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   /**
 146:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      \ingroup avr_math
 147:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 148:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      The sin() function returns the sine of \a __x, measured in radians.
 149:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   */
 150:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** extern double sin(double __x) __ATTR_CONST__;
 151:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 152:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   /**
 153:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      \ingroup avr_math
 154:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 155:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      The sqrt() function returns the non-negative square root of \a __x.
 156:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   */
 157:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** extern double sqrt(double __x) __ATTR_CONST__;
 158:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 159:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   /**
 160:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      \ingroup avr_math
 161:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 162:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      The tan() function returns the tangent of \a __x, measured in
 163:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      radians.
 164:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   */
 165:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** extern double tan(double __x) __ATTR_CONST__;
 166:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 167:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   /**
 168:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      \ingroup avr_math
 169:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 170:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      The floor() function returns the largest integral value less than or
 171:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      equal to \a __x, expressed as a floating-point number.
 172:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   */
 173:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** extern double floor(double __x) __ATTR_CONST__;
 174:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 175:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   /**
 176:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      \ingroup avr_math
 177:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 178:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      The ceil() function returns the smallest integral value greater than
 179:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      or equal to \a __x, expressed as a floating-point number.
 180:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   */
 181:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** extern double ceil(double __x) __ATTR_CONST__;
 182:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 183:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   /**
 184:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      \ingroup avr_math
 185:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 186:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      The frexp() function breaks a floating-point number into a normalized
 187:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      fraction and an integral power of 2.  It stores the integer in the \c
 188:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      int object pointed to by \a __pexp.
 189:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 190:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      If \a __x is a normal float point number, the frexp() function
 191:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      returns the value \c v, such that \c v has a magnitude in the
 192:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      interval [1/2, 1) or zero, and \a __x equals \c v times 2 raised to
 193:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      the power \a __pexp. If \a __x is zero, both parts of the result are
 194:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      zero. If \a __x is not a finite number, the frexp() returns \a __x as
 195:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      is and stores 0 by \a __pexp.
 196:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 197:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      \note  This implementation permits a zero pointer as a directive to
 198:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      skip a storing the exponent.
 199:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   */
 200:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** extern double frexp(double __x, int *__pexp);
 201:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 202:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   /**
 203:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      \ingroup avr_math
 204:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 205:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      The ldexp() function multiplies a floating-point number by an integral
 206:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      power of 2.
 207:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 208:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      The ldexp() function returns the value of \a __x times 2 raised to
 209:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      the power \a __exp.
 210:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   */
 211:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** extern double ldexp(double __x, int __exp) __ATTR_CONST__;
 212:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 213:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   /**
 214:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      \ingroup avr_math
 215:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 216:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      The exp() function returns the exponential value of \a __x.
 217:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   */
 218:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** extern double exp(double __x) __ATTR_CONST__;
 219:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 220:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   /**
 221:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      \ingroup avr_math
 222:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 223:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      The cosh() function returns the hyperbolic cosine of \a __x.
 224:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   */
 225:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** extern double cosh(double __x) __ATTR_CONST__;
 226:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 227:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   /**
 228:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      \ingroup avr_math
 229:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 230:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      The sinh() function returns the hyperbolic sine of \a __x.
 231:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   */
 232:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** extern double sinh(double __x) __ATTR_CONST__;
 233:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 234:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   /**
 235:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      \ingroup avr_math
 236:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 237:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      The tanh() function returns the hyperbolic tangent of \a __x.
 238:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   */
 239:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** extern double tanh(double __x) __ATTR_CONST__;
 240:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 241:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   /**
 242:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      \ingroup avr_math
 243:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 244:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      The acos() function computes the principal value of the arc cosine of
 245:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      \a __x.  The returned value is in the range [0, pi] radians. A domain
 246:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      error occurs for arguments not in the range [-1, +1].
 247:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   */
 248:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** extern double acos(double __x) __ATTR_CONST__;
 249:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 250:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   /**
 251:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      \ingroup avr_math
 252:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 253:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      The asin() function computes the principal value of the arc sine of
 254:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      \a __x.  The returned value is in the range [-pi/2, pi/2] radians. A
 255:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      domain error occurs for arguments not in the range [-1, +1].
 256:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   */
 257:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** extern double asin(double __x) __ATTR_CONST__;
 258:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 259:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   /**
 260:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      \ingroup avr_math
 261:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 262:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      The atan() function computes the principal value of the arc tangent
 263:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      of \a __x.  The returned value is in the range [-pi/2, pi/2] radians.
 264:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   */
 265:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** extern double atan(double __x) __ATTR_CONST__;
 266:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 267:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   /**
 268:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      \ingroup avr_math
 269:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      
 270:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      The atan2() function computes the principal value of the arc tangent
 271:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      of <em>__y / __x</em>, using the signs of both arguments to determine
 272:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      the quadrant of the return value.  The returned value is in the range
 273:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      [-pi, +pi] radians.
 274:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   */
 275:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** extern double atan2(double __y, double __x) __ATTR_CONST__;
 276:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 277:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   /**
 278:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      \ingroup avr_math
 279:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 280:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      The log() function returns the natural logarithm of argument \a __x.
 281:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****    */
 282:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** extern double log(double __x) __ATTR_CONST__;
 283:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 284:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   /**
 285:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      \ingroup avr_math
 286:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 287:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      The log10() function returns the logarithm of argument \a __x to base
 288:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      10.
 289:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****    */
 290:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** extern double log10(double __x) __ATTR_CONST__;
 291:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 292:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   /**
 293:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      \ingroup avr_math
 294:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 295:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      The function pow() returns the value of \a __x to the exponent \a __y.
 296:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   */
 297:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** extern double pow(double __x, double __y) __ATTR_CONST__;
 298:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 299:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   /**
 300:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      \ingroup avr_math
 301:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 302:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      The function isnan() returns 1 if the argument \a __x represents a
 303:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      "not-a-number" (NaN) object, otherwise 0.
 304:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   */
 305:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** extern int isnan(double __x) __ATTR_CONST__;
 306:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 307:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   /**
 308:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      \ingroup avr_math
 309:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 310:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      The function isinf() returns 1 if the argument \a __x is positive
 311:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      infinity, -1 if \a __x is negative infinity, and 0 otherwise.
 312:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   */
 313:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** extern int isinf(double __x) __ATTR_CONST__;
 314:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 315:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   /**
 316:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      \ingroup avr_math
 317:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 318:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      The function square() returns <em>__x * __x</em>.
 319:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 320:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      \note
 321:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      This function does not belong to the C standard definition.
 322:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   */
 323:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** extern double square(double __x) __ATTR_CONST__;
 324:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 325:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   /**
 326:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      \ingroup avr_math
 327:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 328:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      The copysign() function returns \a __x but with the sign of \a __y.
 329:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      They work even if \a __x or \a __y are NaN or zero.
 330:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****  */
 331:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** __ATTR_CONST__ extern inline double copysign (double __x, double __y)
 332:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** {
 333:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****     __asm__ (
 108               	.LM0:
 109               	.LFBB1:
 110               	/* prologue: function */
 111               	/* frame size = 0 */
 113               	.LM1:
 114               	/* #APP */
 115               	 ;  333 "/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h" 1
 116 0000 57FB      		bst	r21, 7	
 117 0002 97F9      		bld	r25, 7	
 118               	 ;  0 "" 2
 119               	/* epilogue start */
 334:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 	"bst	%D2, 7	\n\t"
 335:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 	"bld	%D0, 7	"
 336:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 	: "=r" (__x)
 337:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 	: "0" (__x), "r" (__y) );
 338:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****     return __x;
 339:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** }
 121               	.LM2:
 122               	/* #NOAPP */
 123 0004 0895      		ret
 125               	.Lscope1:
 128               	.global	isfinite
 130               	isfinite:
 340:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 341:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   /**
 342:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      \ingroup avr_math
 343:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 344:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      The fdim() function returns <em>max(__x - __y, 0)</em>. If \a __x or
 345:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      \a __y or both are NaN, NaN is returned.
 346:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   */
 347:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** extern double fdim (double __x, double __y) __ATTR_CONST__;
 348:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 349:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   /**
 350:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      \ingroup avr_math
 351:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 352:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      The fma() function performs floating-point multiply-add. This is the
 353:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      operation <em>(__x * __y) + __z</em>, but the intermediate result is
 354:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      not rounded to the destination type.  This can sometimes improve the
 355:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      precision of a calculation.
 356:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   */
 357:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** extern double fma (double __x, double __y, double __z) __ATTR_CONST__;
 358:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 359:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   /**
 360:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      \ingroup avr_math
 361:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 362:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      The fmax() function returns the greater of the two values \a __x and
 363:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      \a __y. If an argument is NaN, the other argument is returned. If
 364:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      both arguments are NaN, NaN is returned.
 365:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   */
 366:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** extern double fmax (double __x, double __y) __ATTR_CONST__;
 367:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 368:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   /**
 369:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      \ingroup avr_math
 370:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 371:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      The fmin() function returns the lesser of the two values \a __x and
 372:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      \a __y. If an argument is NaN, the other argument is returned. If
 373:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      both arguments are NaN, NaN is returned.
 374:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   */
 375:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** extern double fmin (double __x, double __y) __ATTR_CONST__;
 376:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 377:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   /**
 378:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      \ingroup avr_math
 379:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 380:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      The signbit() function returns a nonzero value if the value of \a __x
 381:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      has its sign bit set.  This is not the same as `\a __x < 0.0',
 382:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      because IEEE 754 floating point allows zero to be signed. The
 383:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      comparison `-0.0 < 0.0' is false, but `signbit (-0.0)' will return a
 384:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      nonzero value.
 385:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      
 386:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      \note
 387:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      This implementation returns 1 if sign bit is set.
 388:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   */
 389:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** extern int signbit (double __x) __ATTR_CONST__;
 390:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 391:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   /**
 392:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      \ingroup avr_math
 393:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 394:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      The trunc() function rounds \a __x to the nearest integer not larger
 395:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      in absolute value.
 396:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   */
 397:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** extern double trunc (double __x) __ATTR_CONST__;
 398:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 399:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   /**
 400:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      \ingroup avr_math
 401:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 
 402:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      The isfinite() function returns a nonzero value if \a __x is finite:
 403:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****      not plus or minus infinity, and not NaN.
 404:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****   */
 405:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** __ATTR_CONST__ extern inline int isfinite (double __x)
 406:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** {
 132               	.LM3:
 133               	.LFBB2:
 134               	/* prologue: function */
 135               	/* frame size = 0 */
 407:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****     unsigned char __exp;
 408:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****     __asm__ (
 137               	.LM4:
 138               	/* #APP */
 139               	 ;  408 "/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h" 1
 140 0006 682F      		mov	r22, r24		
 141 0008 660F      		lsl	r22		
 142 000a 692F      		mov	r22, r25		
 143 000c 661F      		rol	r22		
 144               	 ;  0 "" 2
 145               	/* #NOAPP */
 146 000e 20E0      		ldi r18,lo8(0)
 147 0010 30E0      		ldi r19,hi8(0)
 148 0012 6F3F      		cpi r22,lo8(-1)
 149 0014 01F0      		breq .L4
 150 0016 21E0      		ldi r18,lo8(1)
 151 0018 30E0      		ldi r19,hi8(1)
 152               	.L4:
 409:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 	"mov	%0, %C1		\n\t"
 410:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 	"lsl	%0		\n\t"
 411:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 	"mov	%0, %D1		\n\t"
 412:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 	"rol	%0		"
 413:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 	: "=r" (__exp)
 414:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** 	: "r" (__x)	);
 415:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h ****     return __exp != 0xff;
 416:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/math.h **** }
 154               	.LM5:
 155 001a C901      		movw r24,r18
 156               	/* epilogue start */
 157 001c 0895      		ret
 162               	.Lscope2:
 166               	.global	max
 168               	max:
 170               	.Ltext2:
   1:adc.c         **** /*
   2:adc.c         **** Controls and Provides access to the Analog to Digital Converter (ADC) subsystem of the avr
   3:adc.c         **** */
   4:adc.c         **** 
   5:adc.c         **** #include "defines.h"
   6:adc.c         **** #include "adc.h"
   7:adc.c         **** #include <avr/interrupt.h>
   8:adc.c         **** #include <avr/io.h>
   9:adc.c         **** #include <avr/sleep.h>
  10:adc.c         **** #include <avr/power.h>
  11:adc.c         **** #include <stdio.h>
  12:adc.c         **** #include <math.h>
  13:adc.c         **** #include <util/delay_basic.h>
  14:adc.c         **** #include <avr/pgmspace.h>
  15:adc.c         **** #include <string.h>
  16:adc.c         **** 
  17:adc.c         **** uint8_t max(uint16_t val[],uint8_t sz) {
 172               	.LM6:
 173               	.LFBB3:
 174               	/* prologue: function */
 175               	/* frame size = 0 */
 176 001e 862F      		mov r24,r22
 177               	/* epilogue start */
  18:adc.c         **** 	uint8_t tmpi=sz,tmpv=0;
  19:adc.c         **** 	for(uint8_t c=0;c<sz;++c)
  20:adc.c         **** 		if (val[c]<tmpv) {
  21:adc.c         **** 			tmpi=c;
  22:adc.c         **** 			tmpv=val[c];
  23:adc.c         **** 		}
  24:adc.c         **** 	return tmpi;
  25:adc.c         **** }
 179               	.LM7:
 180 0020 0895      		ret
 182               	.Lscope3:
 185               	.global	adc_get_val
 187               	adc_get_val:
  26:adc.c         **** 
  27:adc.c         **** void print_adc_values() {
  28:adc.c         **** 	fprintf_P(stderr,PSTR("\n[debug]   RAW ADC: "));
  29:adc.c         **** 	for (uint8_t chan=0;chan<channel_amt;chan++) 
  30:adc.c         **** 		fprintf(stderr," [ %d : %d ] ", chan, adc_val[chan]);
  31:adc.c         **** 	
  32:adc.c         **** 	fprintf_P(stderr,PSTR("\n[debug] FIXED ADC: "));
  33:adc.c         **** 	for (uint8_t chan=0;chan<channel_amt;chan++) 
  34:adc.c         **** 		fprintf(stderr," [ %d : %d ] ", chan, adc_get_val(chan));
  35:adc.c         **** }
  36:adc.c         **** 
  37:adc.c         **** void print_adc_calibration() {
  38:adc.c         **** 	fprintf_P(stderr,PSTR("\n[debug] ADC OFFSETS: "));
  39:adc.c         **** 	for (uint8_t chan=0;chan<channel_amt;chan++) 
  40:adc.c         **** 		fprintf(stderr," [ %d : %d ] ", chan, adc_offset[chan]);
  41:adc.c         **** }
  42:adc.c         **** 
  43:adc.c         **** 
  44:adc.c         **** uint16_t adc_get_val(uint8_t ch) {
 189               	.LM8:
 190               	.LFBB4:
 191               	/* prologue: function */
 192               	/* frame size = 0 */
  45:adc.c         **** 	return adc_val[ch]+adc_offset[ch];
 194               	.LM9:
 195 0022 E82F      		mov r30,r24
 196 0024 F0E0      		ldi r31,lo8(0)
 197 0026 EE0F      		lsl r30
 198 0028 FF1F      		rol r31
 199 002a DF01      		movw r26,r30
 200 002c A050      		subi r26,lo8(-(adc_val))
 201 002e B040      		sbci r27,hi8(-(adc_val))
 202 0030 E050      		subi r30,lo8(-(adc_offset))
 203 0032 F040      		sbci r31,hi8(-(adc_offset))
 204 0034 2081      		ld r18,Z
 205 0036 3181      		ldd r19,Z+1
 206 0038 8D91      		ld r24,X+
 207 003a 9C91      		ld r25,X
 208 003c 280F      		add r18,r24
 209 003e 391F      		adc r19,r25
  46:adc.c         **** }
 211               	.LM10:
 212 0040 C901      		movw r24,r18
 213               	/* epilogue start */
 214 0042 0895      		ret
 216               	.Lscope4:
 219               	.global	adc_set_channel
 221               	adc_set_channel:
  47:adc.c         **** 
  48:adc.c         **** static uint8_t num_calibrations;
  49:adc.c         **** void adc_calibrate_update() {
  50:adc.c         **** 	int16_t offsets[channel_amt];
  51:adc.c         **** 	uint16_t adc_val_cpy[channel_amt];
  52:adc.c         **** 	memcpy(adc_val_cpy,adc_val,sizeof(adc_val));
  53:adc.c         **** 	
  54:adc.c         **** 	
  55:adc.c         **** 	uint8_t i=0,val=0;
  56:adc.c         **** 	for(uint8_t c=0;c<channel_amt;++c) {
  57:adc.c         **** 		if(val>adc_val_cpy[c]) {
  58:adc.c         **** 			i=c;
  59:adc.c         **** 			val=adc_val_cpy[c];
  60:adc.c         **** 		}
  61:adc.c         **** 	}
  62:adc.c         **** 	
  63:adc.c         **** 	for(uint8_t c=0;c<channel_amt;++c) {
  64:adc.c         **** 		offsets[c]=adc_val_cpy[i]-adc_val_cpy[c];
  65:adc.c         **** 	}
  66:adc.c         **** 		
  67:adc.c         **** 	if (num_calibrations==0)
  68:adc.c         **** 		memcpy(adc_offset,offsets,sizeof(adc_offset));
  69:adc.c         **** 	else
  70:adc.c         **** 		for(uint8_t c=0;c<channel_amt;++c) {
  71:adc.c         **** 			adc_offset[c]=(adc_offset[c] * num_calibrations + offsets[c])/(num_calibrations+1);
  72:adc.c         **** 		}
  73:adc.c         **** 			
  74:adc.c         **** 	++num_calibrations;
  75:adc.c         **** }
  76:adc.c         **** 
  77:adc.c         **** void adc_calibrate_store() {
  78:adc.c         **** 	fprintf_P(stderr,PSTR("\n[debug] Warning: unimplimented function adc_calibrate_store called"));
  79:adc.c         **** }
  80:adc.c         **** 
  81:adc.c         **** void adc_calibrate_clear() {
  82:adc.c         **** 	//for(uint8_t j= 0;j<channel_amt;++j)
  83:adc.c         **** 	//	adc_offset[j]=0;
  84:adc.c         **** 	memset(adc_offset,0,sizeof(adc_offset));
  85:adc.c         **** 	num_calibrations = 0;
  86:adc.c         **** }
  87:adc.c         **** 
  88:adc.c         **** void adc_init() {
  89:adc.c         **** 	#ifdef debug
  90:adc.c         **** 	fprintf_P(stderr,PSTR("\nadc: init"));
  91:adc.c         **** 	#endif
  92:adc.c         **** 	power_adc_enable();
  93:adc.c         **** 
  94:adc.c         **** 	//Set Voltage to AVCC with external capacitor at AREF pin
  95:adc.c         **** 	ADMUX|= (uint8_t)(1<<REFS0);
  96:adc.c         **** 	ADMUX&=(uint8_t)~(1<<REFS1);
  97:adc.c         **** 	//ADMUX&=~(1<<ADLAR); // Default disabled
  98:adc.c         **** 	
  99:adc.c         **** 	// Enable ADC, Inturupt, Trigger mode and set prescaler
 100:adc.c         **** 	//ADCSRA=(((1<<ADEN)|(1<<ADIE)|(1<<ADATE))&0b11111000)|(ADC_PRESCALE);
 101:adc.c         **** 	ADCSRA|= (uint8_t)(1<<ADEN)|(1<<ADIE)|(1<<ADATE);
 102:adc.c         **** 	ADCSRA = (uint8_t)(ADCSRA & 0b11111000)|((uint8_t)ADC_PRESCALE);
 103:adc.c         **** 	
 104:adc.c         **** 	// Enable Free Running Mode 
 105:adc.c         **** 	ADCSRB|= (1<<7); //reserved bit.
 106:adc.c         **** 	ADCSRB&= (uint8_t)~(0b111); //(ADTS2:0)=0
 107:adc.c         **** 	
 108:adc.c         **** 	// Disable Digital reads from analog pins
 109:adc.c         **** 	DIDR0 |= (uint8_t)((1<<ADC4D)|(1<<ADC5D)|(1<<ADC6D)|(1<<ADC7D));
 110:adc.c         **** 	
 111:adc.c         **** 	set_sleep_mode(SLEEP_MODE_ADC);
 112:adc.c         **** 	#ifdef debug	
 113:adc.c         **** 	fprintf_P(stderr,PSTR("\nadc: init: setup convertions"));
 114:adc.c         **** 	#endif
 115:adc.c         **** 	adc_set_channel(curr_ch);
 116:adc.c         **** 	//Start the convertions
 117:adc.c         **** 	ADCSRA|= (1<<ADSC);
 118:adc.c         **** 
 119:adc.c         **** 	// Wait one adc clock cycle and change the channel, done by interupt later.
 120:adc.c         **** 	_delay_loop_2(ADC_CYCLE_DELAY);
 121:adc.c         **** 	adc_set_channel(++curr_ch);
 122:adc.c         **** 	
 123:adc.c         **** 	// Wait for one set of convertions to complete.
 124:adc.c         **** 	//_delay_loop_2(ADC_CYCLE_DELAY*26);
 125:adc.c         **** 	#ifdef debug
 126:adc.c         **** 	fprintf_P(stderr,PSTR("\t[done]"));
 127:adc.c         **** 	#endif
 128:adc.c         **** }
 129:adc.c         **** 
 130:adc.c         **** void adc_set_channel(uint8_t channel) {
 223               	.LM11:
 224               	.LFBB5:
 225               	/* prologue: function */
 226               	/* frame size = 0 */
 131:adc.c         **** 	//Prescale reset on each "trigger event"s
 132:adc.c         **** 	//From Data Sheet: (Switching to Free Running mode (ADTS[2:0]=0) will)
 133:adc.c         **** 	//(not cause a trigger event, even if the ADC Interrupt Flag is set.)
 134:adc.c         **** 	ADMUX  = (uint8_t)((uint8_t)(ADMUX &0b11100000)|channels[channel]);
 228               	.LM12:
 229 0044 ACE7      		ldi r26,lo8(124)
 230 0046 B0E0      		ldi r27,hi8(124)
 231 0048 9C91      		ld r25,X
 232 004a E0E0      		ldi r30,lo8(channels)
 233 004c F0E0      		ldi r31,hi8(channels)
 234 004e E80F      		add r30,r24
 235 0050 F11D      		adc r31,__zero_reg__
 236 0052 907E      		andi r25,lo8(-32)
 237 0054 8081      		ld r24,Z
 238 0056 982B      		or r25,r24
 239 0058 9C93      		st X,r25
 240               	/* epilogue start */
 135:adc.c         **** 	//print_adc_values();
 136:adc.c         **** 	//printf("V - chan %X\n",channel);
 137:adc.c         **** }
 242               	.LM13:
 243 005a 0895      		ret
 245               	.Lscope5:
 247               	.global	__vector_19
 249               	__vector_19:
 138:adc.c         **** 
 139:adc.c         **** //ADC Interupt handler
 140:adc.c         **** ISR(ADC_vect) {
 251               	.LM14:
 252               	.LFBB6:
 253 005c 1F92      		push __zero_reg__
 254 005e 0F92      		push r0
 255 0060 0FB6      		in r0,__SREG__
 256 0062 0F92      		push r0
 257 0064 1124      		clr __zero_reg__
 258 0066 2F93      		push r18
 259 0068 3F93      		push r19
 260 006a 4F93      		push r20
 261 006c 5F93      		push r21
 262 006e 8F93      		push r24
 263 0070 9F93      		push r25
 264 0072 AF93      		push r26
 265 0074 BF93      		push r27
 266 0076 EF93      		push r30
 267 0078 FF93      		push r31
 268               	/* prologue: Signal */
 269               	/* frame size = 0 */
 141:adc.c         **** 	// New conversion has already started.
 142:adc.c         **** 	uint16_t adc_value;
 143:adc.c         **** 	adc_value  =  ADCL;  
 271               	.LM15:
 272 007a 5091 7800 		lds r21,120
 144:adc.c         **** 	adc_value += (ADCH<<8);
 274               	.LM16:
 275 007e 4091 7900 		lds r20,121
 145:adc.c         **** 	uint8_t real_channel;
 146:adc.c         **** 	static uint8_t ct;
 147:adc.c         **** 	++ct;
 277               	.LM17:
 278 0082 3091 0000 		lds r19,ct.1881
 279 0086 3F5F      		subi r19,lo8(-(1))
 280 0088 3093 0000 		sts ct.1881,r19
 148:adc.c         **** 
 149:adc.c         **** 	// the curr_ch now has the chan of the on going conversion, we need the last one
 150:adc.c         **** 	if (curr_ch==0)	real_channel = channel_amt-1; //curr_ch==0 
 282               	.LM18:
 283 008c 2091 0000 		lds r18,curr_ch
 284 0090 2223      		tst r18
 285 0092 01F4      		brne .L13
 286 0094 E3E0      		ldi r30,lo8(3)
 287 0096 00C0      		rjmp .L14
 288               	.L13:
 151:adc.c         **** 	else		real_channel = curr_ch-1;
 290               	.LM19:
 291 0098 E22F      		mov r30,r18
 292 009a E150      		subi r30,lo8(-(-1))
 293               	.L14:
 152:adc.c         **** 
 153:adc.c         **** 	adc_val[real_channel] = adc_value;
 295               	.LM20:
 296 009c F0E0      		ldi r31,lo8(0)
 297 009e EE0F      		lsl r30
 298 00a0 FF1F      		rol r31
 299 00a2 DF01      		movw r26,r30
 300 00a4 A050      		subi r26,lo8(-(adc_val))
 301 00a6 B040      		sbci r27,hi8(-(adc_val))
 302 00a8 942F      		mov r25,r20
 303 00aa 80E0      		ldi r24,lo8(0)
 304 00ac 850F      		add r24,r21
 305 00ae 911D      		adc r25,__zero_reg__
 306 00b0 8D93      		st X+,r24
 307 00b2 9C93      		st X,r25
 154:adc.c         **** 	++adc_amt[real_channel];
 309               	.LM21:
 310 00b4 E050      		subi r30,lo8(-(adc_amt))
 311 00b6 F040      		sbci r31,hi8(-(adc_amt))
 312 00b8 8081      		ld r24,Z
 313 00ba 9181      		ldd r25,Z+1
 314 00bc 0196      		adiw r24,1
 315 00be 9183      		std Z+1,r25
 316 00c0 8083      		st Z,r24
 155:adc.c         **** 
 156:adc.c         **** 	// Change the channel for the conversion after the one currently processing.
 157:adc.c         **** 	if (++curr_ch >= channel_amt)	curr_ch = 0;
 318               	.LM22:
 319 00c2 822F      		mov r24,r18
 320 00c4 8F5F      		subi r24,lo8(-(1))
 321 00c6 8093 0000 		sts curr_ch,r24
 322 00ca 8430      		cpi r24,lo8(4)
 323 00cc 00F0      		brlo .L15
 324 00ce 1092 0000 		sts curr_ch,__zero_reg__
 325               	.L15:
 326               	.LBB19:
 327               	.LBB20:
 329               	.LM23:
 330 00d2 9091 7C00 		lds r25,124
 331 00d6 E091 0000 		lds r30,curr_ch
 332 00da F0E0      		ldi r31,lo8(0)
 333 00dc E050      		subi r30,lo8(-(channels))
 334 00de F040      		sbci r31,hi8(-(channels))
 335 00e0 907E      		andi r25,lo8(-32)
 336 00e2 8081      		ld r24,Z
 337 00e4 982B      		or r25,r24
 338 00e6 9093 7C00 		sts 124,r25
 339               	.LBE20:
 340               	.LBE19:
 158:adc.c         **** 	
 159:adc.c         **** 	adc_set_channel(curr_ch);
 160:adc.c         **** 	
 161:adc.c         **** 	//printf("adc_value: %d",adc_value);
 162:adc.c         **** 	
 163:adc.c         **** 	//TODO: modify for running average (Ave= (Ave*(ct-1)+New)/ct)
 164:adc.c         **** 	//INFO: Vin[V]=(ADCH256+ADCL)Vref[V]/1024
 165:adc.c         **** 	
 166:adc.c         **** 	if (!(ct%channel_amt)) {
 342               	.LM24:
 343 00ea 832F      		mov r24,r19
 344 00ec 90E0      		ldi r25,lo8(0)
 345 00ee 8370      		andi r24,lo8(3)
 346 00f0 9070      		andi r25,hi8(3)
 347 00f2 892B      		or r24,r25
 348 00f4 01F4      		brne .L17
 167:adc.c         **** 		new_adc_data=true;//all values have been recalculated, update motors.
 350               	.LM25:
 351 00f6 81E0      		ldi r24,lo8(1)
 352 00f8 8093 0000 		sts new_adc_data,r24
 353               	.L17:
 354               	/* epilogue start */
 168:adc.c         **** 	}
 169:adc.c         **** }
 356               	.LM26:
 357 00fc FF91      		pop r31
 358 00fe EF91      		pop r30
 359 0100 BF91      		pop r27
 360 0102 AF91      		pop r26
 361 0104 9F91      		pop r25
 362 0106 8F91      		pop r24
 363 0108 5F91      		pop r21
 364 010a 4F91      		pop r20
 365 010c 3F91      		pop r19
 366 010e 2F91      		pop r18
 367 0110 0F90      		pop r0
 368 0112 0FBE      		out __SREG__,r0
 369 0114 0F90      		pop r0
 370 0116 1F90      		pop __zero_reg__
 371 0118 1895      		reti
 377               	.Lscope6:
 379               	.global	adc_init
 381               	adc_init:
 383               	.LM27:
 384               	.LFBB7:
 385 011a EF92      		push r14
 386 011c FF92      		push r15
 387 011e 0F93      		push r16
 388 0120 1F93      		push r17
 389               	/* prologue: function */
 390               	/* frame size = 0 */
 392               	.LM28:
 393 0122 80E0      		ldi r24,lo8(__c.1821)
 394 0124 90E0      		ldi r25,hi8(__c.1821)
 395 0126 9F93      		push r25
 396 0128 8F93      		push r24
 397 012a 8091 0000 		lds r24,__iob+4
 398 012e 9091 0000 		lds r25,(__iob+4)+1
 399 0132 9F93      		push r25
 400 0134 8F93      		push r24
 401 0136 0E94 0000 		call fprintf_P
 403               	.LM29:
 404 013a E4E6      		ldi r30,lo8(100)
 405 013c F0E0      		ldi r31,hi8(100)
 406 013e 8081      		ld r24,Z
 407 0140 8E7F      		andi r24,lo8(-2)
 408 0142 8083      		st Z,r24
 410               	.LM30:
 411 0144 0CE7      		ldi r16,lo8(124)
 412 0146 10E0      		ldi r17,hi8(124)
 413 0148 F801      		movw r30,r16
 414 014a 8081      		ld r24,Z
 415 014c 8064      		ori r24,lo8(64)
 416 014e 8083      		st Z,r24
 418               	.LM31:
 419 0150 8081      		ld r24,Z
 420 0152 8F77      		andi r24,lo8(127)
 421 0154 8083      		st Z,r24
 423               	.LM32:
 424 0156 2AE7      		ldi r18,lo8(122)
 425 0158 E22E      		mov r14,r18
 426 015a F12C      		mov r15,__zero_reg__
 427 015c F701      		movw r30,r14
 428 015e 8081      		ld r24,Z
 429 0160 886A      		ori r24,lo8(-88)
 430 0162 8083      		st Z,r24
 432               	.LM33:
 433 0164 8081      		ld r24,Z
 434 0166 887F      		andi r24,lo8(-8)
 435 0168 8660      		ori r24,lo8(6)
 436 016a 8083      		st Z,r24
 438               	.LM34:
 439 016c EBE7      		ldi r30,lo8(123)
 440 016e F0E0      		ldi r31,hi8(123)
 441 0170 8081      		ld r24,Z
 442 0172 8068      		ori r24,lo8(-128)
 443 0174 8083      		st Z,r24
 445               	.LM35:
 446 0176 8081      		ld r24,Z
 447 0178 887F      		andi r24,lo8(-8)
 448 017a 8083      		st Z,r24
 450               	.LM36:
 451 017c EEE7      		ldi r30,lo8(126)
 452 017e F0E0      		ldi r31,hi8(126)
 453 0180 8081      		ld r24,Z
 454 0182 806F      		ori r24,lo8(-16)
 455 0184 8083      		st Z,r24
 457               	.LM37:
 458 0186 83B7      		in r24,83-0x20
 459 0188 817F      		andi r24,lo8(-15)
 460 018a 8260      		ori r24,lo8(2)
 461 018c 83BF      		out 83-0x20,r24
 463               	.LM38:
 464 018e 80E0      		ldi r24,lo8(__c.1823)
 465 0190 90E0      		ldi r25,hi8(__c.1823)
 466 0192 9F93      		push r25
 467 0194 8F93      		push r24
 468 0196 8091 0000 		lds r24,__iob+4
 469 019a 9091 0000 		lds r25,(__iob+4)+1
 470 019e 9F93      		push r25
 471 01a0 8F93      		push r24
 472 01a2 0E94 0000 		call fprintf_P
 474               	.LM39:
 475 01a6 2091 0000 		lds r18,curr_ch
 476               	.LBB21:
 477               	.LBB22:
 479               	.LM40:
 480 01aa F801      		movw r30,r16
 481 01ac 8081      		ld r24,Z
 482 01ae A0E0      		ldi r26,lo8(channels)
 483 01b0 B0E0      		ldi r27,hi8(channels)
 484 01b2 FD01      		movw r30,r26
 485 01b4 E20F      		add r30,r18
 486 01b6 F11D      		adc r31,__zero_reg__
 487 01b8 807E      		andi r24,lo8(-32)
 488 01ba 9081      		ld r25,Z
 489 01bc 892B      		or r24,r25
 490 01be F801      		movw r30,r16
 491 01c0 8083      		st Z,r24
 492               	.LBE22:
 493               	.LBE21:
 495               	.LM41:
 496 01c2 F701      		movw r30,r14
 497 01c4 8081      		ld r24,Z
 498 01c6 8064      		ori r24,lo8(64)
 499 01c8 8083      		st Z,r24
 500               	.LBB23:
 501               	.LBB24:
 503               	.Ltext3:
   1:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****    Copyright (c) 2007 Joerg Wunsch
   3:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****    All rights reserved.
   4:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h **** 
   5:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****    Redistribution and use in source and binary forms, with or without
   6:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****    modification, are permitted provided that the following conditions are met:
   7:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h **** 
   8:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****    * Redistributions of source code must retain the above copyright
   9:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****      notice, this list of conditions and the following disclaimer.
  10:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h **** 
  11:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****    * Redistributions in binary form must reproduce the above copyright
  12:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****      notice, this list of conditions and the following disclaimer in
  13:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****      the documentation and/or other materials provided with the
  14:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****      distribution.
  15:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h **** 
  16:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****    * Neither the name of the copyright holders nor the names of
  17:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****      contributors may be used to endorse or promote products derived
  18:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****      from this software without specific prior written permission.
  19:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h **** 
  20:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h **** 
  32:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h **** /* $Id: delay_basic.h,v 1.1 2007/05/13 21:23:20 joerg_wunsch Exp $ */
  33:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h **** 
  34:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h **** #ifndef _UTIL_DELAY_BASIC_H_
  35:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h **** #define _UTIL_DELAY_BASIC_H_ 1
  36:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h **** 
  37:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h **** #include <inttypes.h>
  38:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h **** 
  39:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h **** /** \file */
  40:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h **** /** \defgroup util_delay_basic <util/delay_basic.h>: Basic busy-wait delay loops
  41:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****     \code
  42:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****     #include <util/delay_basic.h>
  43:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****     \endcode
  44:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h **** 
  45:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****     The functions in this header file implement simple delay loops
  46:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****     that perform a busy-waiting.  They are typically used to
  47:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****     facilitate short delays in the program execution.  They are
  48:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****     implemented as count-down loops with a well-known CPU cycle
  49:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****     count per loop iteration.  As such, no other processing can
  50:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****     occur simultaneously.  It should be kept in mind that the
  51:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****     functions described here do not disable interrupts.
  52:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h **** 
  53:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****     In general, for long delays, the use of hardware timers is
  54:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****     much preferrable, as they free the CPU, and allow for
  55:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****     concurrent processing of other events while the timer is
  56:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****     running.  However, in particular for very short delays, the
  57:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****     overhead of setting up a hardware timer is too much compared
  58:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****     to the overall delay time.
  59:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h **** 
  60:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****     Two inline functions are provided for the actual delay algorithms.
  61:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h **** 
  62:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h **** */
  63:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h **** 
  64:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h **** #if !defined(__DOXYGEN__)
  65:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h **** static inline void _delay_loop_1(uint8_t __count) __attribute__((always_inline));
  66:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h **** static inline void _delay_loop_2(uint16_t __count) __attribute__((always_inline));
  67:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h **** #endif
  68:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h **** 
  69:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h **** /** \ingroup util_delay_basic
  70:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h **** 
  71:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****     Delay loop using an 8-bit counter \c __count, so up to 256
  72:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****     iterations are possible.  (The value 256 would have to be passed
  73:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****     as 0.)  The loop executes three CPU cycles per iteration, not
  74:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****     including the overhead the compiler needs to setup the counter
  75:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****     register.
  76:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h **** 
  77:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to 768 microseconds
  78:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****     can be achieved.
  79:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h **** */
  80:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h **** void
  81:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h **** _delay_loop_1(uint8_t __count)
  82:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h **** {
  83:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h **** 	__asm__ volatile (
  84:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h **** 		"1: dec %0" "\n\t"
  85:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h **** 		"brne 1b"
  86:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h **** 		: "=r" (__count)
  87:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h **** 		: "0" (__count)
  88:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h **** 	);
  89:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h **** }
  90:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h **** 
  91:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h **** /** \ingroup util_delay_basic
  92:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h **** 
  93:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****     Delay loop using a 16-bit counter \c __count, so up to 65536
  94:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****     iterations are possible.  (The value 65536 would have to be
  95:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****     passed as 0.)  The loop executes four CPU cycles per iteration,
  96:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****     not including the overhead the compiler requires to setup the
  97:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****     counter register pair.
  98:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h **** 
  99:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to about 262.1
 100:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****     milliseconds can be achieved.
 101:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h ****  */
 102:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h **** void
 103:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h **** _delay_loop_2(uint16_t __count)
 104:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h **** {
 105:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h **** 	__asm__ volatile (
 505               	.LM42:
 506 01ca 80E0      		ldi r24,lo8(0)
 507 01cc 90E0      		ldi r25,hi8(0)
 508               	/* #APP */
 509               	 ;  105 "/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/delay_basic.h" 1
 510 01ce 0197      		1: sbiw r24,1
 511 01d0 01F4      		brne 1b
 512               	 ;  0 "" 2
 513               	/* #NOAPP */
 514               	.LBE24:
 515               	.LBE23:
 517               	.Ltext4:
 519               	.LM43:
 520 01d2 2F5F      		subi r18,lo8(-(1))
 521 01d4 2093 0000 		sts curr_ch,r18
 522               	.LBB25:
 523               	.LBB26:
 525               	.LM44:
 526 01d8 F801      		movw r30,r16
 527 01da 8081      		ld r24,Z
 528 01dc A20F      		add r26,r18
 529 01de B11D      		adc r27,__zero_reg__
 530 01e0 807E      		andi r24,lo8(-32)
 531 01e2 9C91      		ld r25,X
 532 01e4 892B      		or r24,r25
 533 01e6 8083      		st Z,r24
 534               	.LBE26:
 535               	.LBE25:
 537               	.LM45:
 538 01e8 80E0      		ldi r24,lo8(__c.1825)
 539 01ea 90E0      		ldi r25,hi8(__c.1825)
 540 01ec 9F93      		push r25
 541 01ee 8F93      		push r24
 542 01f0 8091 0000 		lds r24,__iob+4
 543 01f4 9091 0000 		lds r25,(__iob+4)+1
 544 01f8 9F93      		push r25
 545 01fa 8F93      		push r24
 546 01fc 0E94 0000 		call fprintf_P
 547 0200 8DB7      		in r24,__SP_L__
 548 0202 9EB7      		in r25,__SP_H__
 549 0204 0C96      		adiw r24,12
 550 0206 0FB6      		in __tmp_reg__,__SREG__
 551 0208 F894      		cli
 552 020a 9EBF      		out __SP_H__,r25
 553 020c 0FBE      		out __SREG__,__tmp_reg__
 554 020e 8DBF      		out __SP_L__,r24
 555               	/* epilogue start */
 557               	.LM46:
 558 0210 1F91      		pop r17
 559 0212 0F91      		pop r16
 560 0214 FF90      		pop r15
 561 0216 EF90      		pop r14
 562 0218 0895      		ret
 567               	.Lscope7:
 569               	.global	adc_calibrate_store
 571               	adc_calibrate_store:
 573               	.LM47:
 574               	.LFBB8:
 575               	/* prologue: function */
 576               	/* frame size = 0 */
 578               	.LM48:
 579 021a 80E0      		ldi r24,lo8(__c.1814)
 580 021c 90E0      		ldi r25,hi8(__c.1814)
 581 021e 9F93      		push r25
 582 0220 8F93      		push r24
 583 0222 8091 0000 		lds r24,__iob+4
 584 0226 9091 0000 		lds r25,(__iob+4)+1
 585 022a 9F93      		push r25
 586 022c 8F93      		push r24
 587 022e 0E94 0000 		call fprintf_P
 588 0232 0F90      		pop __tmp_reg__
 589 0234 0F90      		pop __tmp_reg__
 590 0236 0F90      		pop __tmp_reg__
 591 0238 0F90      		pop __tmp_reg__
 592               	/* epilogue start */
 594               	.LM49:
 595 023a 0895      		ret
 597               	.Lscope8:
 599               	.global	adc_calibrate_clear
 601               	adc_calibrate_clear:
 603               	.LM50:
 604               	.LFBB9:
 605               	/* prologue: function */
 606               	/* frame size = 0 */
 608               	.LM51:
 609 023c 88E0      		ldi r24,lo8(8)
 610 023e E0E0      		ldi r30,lo8(adc_offset)
 611 0240 F0E0      		ldi r31,hi8(adc_offset)
 612 0242 DF01      		movw r26,r30
 613 0244 1D92      		st X+,__zero_reg__
 614 0246 8A95      	        dec r24
 615 0248 01F4      		brne .-6
 617               	.LM52:
 618 024a 1092 0000 		sts num_calibrations,__zero_reg__
 619               	/* epilogue start */
 621               	.LM53:
 622 024e 0895      		ret
 624               	.Lscope9:
 626               	.global	adc_calibrate_update
 628               	adc_calibrate_update:
 630               	.LM54:
 631               	.LFBB10:
 632 0250 CF92      		push r12
 633 0252 DF92      		push r13
 634 0254 EF92      		push r14
 635 0256 FF92      		push r15
 636 0258 0F93      		push r16
 637 025a 1F93      		push r17
 638 025c DF93      		push r29
 639 025e CF93      		push r28
 640 0260 CDB7      		in r28,__SP_L__
 641 0262 DEB7      		in r29,__SP_H__
 642 0264 6097      		sbiw r28,16
 643 0266 0FB6      		in __tmp_reg__,__SREG__
 644 0268 F894      		cli
 645 026a DEBF      		out __SP_H__,r29
 646 026c 0FBE      		out __SREG__,__tmp_reg__
 647 026e CDBF      		out __SP_L__,r28
 648               	/* prologue: function */
 649               	/* frame size = 16 */
 651               	.LM55:
 652 0270 DE01      		movw r26,r28
 653 0272 1996      		adiw r26,9
 654 0274 E0E0      		ldi r30,lo8(adc_val)
 655 0276 F0E0      		ldi r31,hi8(adc_val)
 656 0278 88E0      		ldi r24,lo8(8)
 657               	.L25:
 658 027a 0190      		ld r0,Z+
 659 027c 0D92      		st X+,r0
 660 027e 8150      		subi r24,lo8(-(-1))
 661 0280 01F4      		brne .L25
 662               	.LBB27:
 664               	.LM56:
 665 0282 4985      		ldd r20,Y+9
 666 0284 5A85      		ldd r21,Y+10
 667 0286 20E0      		ldi r18,lo8(0)
 668 0288 30E0      		ldi r19,hi8(0)
 669 028a 8E01      		movw r16,r28
 670 028c 0F5F      		subi r16,lo8(-(1))
 671 028e 1F4F      		sbci r17,hi8(-(1))
 672 0290 BE01      		movw r22,r28
 673 0292 675F      		subi r22,lo8(-(9))
 674 0294 7F4F      		sbci r23,hi8(-(9))
 675               	.L26:
 676 0296 D801      		movw r26,r16
 677 0298 A20F      		add r26,r18
 678 029a B31F      		adc r27,r19
 679 029c FB01      		movw r30,r22
 680 029e E20F      		add r30,r18
 681 02a0 F31F      		adc r31,r19
 682 02a2 8081      		ld r24,Z
 683 02a4 9181      		ldd r25,Z+1
 684 02a6 FA01      		movw r30,r20
 685 02a8 E81B      		sub r30,r24
 686 02aa F90B      		sbc r31,r25
 687 02ac ED93      		st X+,r30
 688 02ae FC93      		st X,r31
 689 02b0 2E5F      		subi r18,lo8(-(2))
 690 02b2 3F4F      		sbci r19,hi8(-(2))
 692               	.LM57:
 693 02b4 2830      		cpi r18,8
 694 02b6 3105      		cpc r19,__zero_reg__
 695 02b8 01F4      		brne .L26
 696               	.LBE27:
 698               	.LM58:
 699 02ba 8091 0000 		lds r24,num_calibrations
 700 02be 9E01      		movw r18,r28
 701 02c0 2F5F      		subi r18,lo8(-(1))
 702 02c2 3F4F      		sbci r19,hi8(-(1))
 703 02c4 8823      		tst r24
 704 02c6 01F4      		brne .L27
 706               	.LM59:
 707 02c8 A0E0      		ldi r26,lo8(adc_offset)
 708 02ca B0E0      		ldi r27,hi8(adc_offset)
 709 02cc F901      		movw r30,r18
 710 02ce 88E0      		ldi r24,lo8(8)
 711               	.L28:
 712 02d0 0190      		ld r0,Z+
 713 02d2 0D92      		st X+,r0
 714 02d4 8150      		subi r24,lo8(-(-1))
 715 02d6 01F4      		brne .L28
 716 02d8 00C0      		rjmp .L29
 717               	.L27:
 718 02da E0E0      		ldi r30,lo8(adc_offset)
 719 02dc F0E0      		ldi r31,hi8(adc_offset)
 720 02de 7901      		movw r14,r18
 721               	.LBB28:
 723               	.LM60:
 724 02e0 082F      		mov r16,r24
 725 02e2 10E0      		ldi r17,lo8(0)
 726 02e4 6801      		movw r12,r16
 727 02e6 0894      		sec
 728 02e8 C11C      		adc r12,__zero_reg__
 729 02ea D11C      		adc r13,__zero_reg__
 730               	.L30:
 731 02ec 8081      		ld r24,Z
 732 02ee 9181      		ldd r25,Z+1
 733 02f0 9C01      		movw r18,r24
 734 02f2 029F      		mul r16,r18
 735 02f4 C001      		movw r24,r0
 736 02f6 039F      		mul r16,r19
 737 02f8 900D      		add r25,r0
 738 02fa 129F      		mul r17,r18
 739 02fc 900D      		add r25,r0
 740 02fe 1124      		clr r1
 741 0300 D701      		movw r26,r14
 742 0302 2D91      		ld r18,X+
 743 0304 3D91      		ld r19,X+
 744 0306 7D01      		movw r14,r26
 745 0308 820F      		add r24,r18
 746 030a 931F      		adc r25,r19
 747 030c B601      		movw r22,r12
 748 030e 0E94 0000 		call __divmodhi4
 749 0312 6193      		st Z+,r22
 750 0314 7193      		st Z+,r23
 752               	.LM61:
 753 0316 B0E0      		ldi r27,hi8(adc_offset+8)
 754 0318 E030      		cpi r30,lo8(adc_offset+8)
 755 031a FB07      		cpc r31,r27
 756 031c 01F4      		brne .L30
 757               	.L29:
 758               	.LBE28:
 760               	.LM62:
 761 031e 8091 0000 		lds r24,num_calibrations
 762 0322 8F5F      		subi r24,lo8(-(1))
 763 0324 8093 0000 		sts num_calibrations,r24
 764               	/* epilogue start */
 766               	.LM63:
 767 0328 6096      		adiw r28,16
 768 032a 0FB6      		in __tmp_reg__,__SREG__
 769 032c F894      		cli
 770 032e DEBF      		out __SP_H__,r29
 771 0330 0FBE      		out __SREG__,__tmp_reg__
 772 0332 CDBF      		out __SP_L__,r28
 773 0334 CF91      		pop r28
 774 0336 DF91      		pop r29
 775 0338 1F91      		pop r17
 776 033a 0F91      		pop r16
 777 033c FF90      		pop r15
 778 033e EF90      		pop r14
 779 0340 DF90      		pop r13
 780 0342 CF90      		pop r12
 781 0344 0895      		ret
 787               	.Lscope10:
 788               		.data
 789               	.LC0:
 790 0000 205B 2025 		.string	" [ %d : %d ] "
 790      6420 3A20 
 790      2564 205D 
 790      2000 
 791               		.text
 793               	.global	print_adc_calibration
 795               	print_adc_calibration:
 797               	.LM64:
 798               	.LFBB11:
 799 0346 0F93      		push r16
 800 0348 1F93      		push r17
 801               	/* prologue: function */
 802               	/* frame size = 0 */
 804               	.LM65:
 805 034a 80E0      		ldi r24,lo8(__c.1757)
 806 034c 90E0      		ldi r25,hi8(__c.1757)
 807 034e 9F93      		push r25
 808 0350 8F93      		push r24
 809 0352 8091 0000 		lds r24,__iob+4
 810 0356 9091 0000 		lds r25,(__iob+4)+1
 811 035a 9F93      		push r25
 812 035c 8F93      		push r24
 813 035e 0E94 0000 		call fprintf_P
 814               	.LBB29:
 816               	.LM66:
 817 0362 8091 0000 		lds r24,adc_offset
 818 0366 9091 0000 		lds r25,(adc_offset)+1
 819 036a 9F93      		push r25
 820 036c 8F93      		push r24
 821 036e 1F92      		push __zero_reg__
 822 0370 1F92      		push __zero_reg__
 823 0372 00E0      		ldi r16,lo8(.LC0)
 824 0374 10E0      		ldi r17,hi8(.LC0)
 825 0376 1F93      		push r17
 826 0378 0F93      		push r16
 827 037a 8091 0000 		lds r24,__iob+4
 828 037e 9091 0000 		lds r25,(__iob+4)+1
 829 0382 9F93      		push r25
 830 0384 8F93      		push r24
 831 0386 0E94 0000 		call fprintf
 832 038a 8091 0000 		lds r24,adc_offset+2
 833 038e 9091 0000 		lds r25,(adc_offset+2)+1
 834 0392 9F93      		push r25
 835 0394 8F93      		push r24
 836 0396 81E0      		ldi r24,lo8(1)
 837 0398 90E0      		ldi r25,hi8(1)
 838 039a 9F93      		push r25
 839 039c 8F93      		push r24
 840 039e 1F93      		push r17
 841 03a0 0F93      		push r16
 842 03a2 8091 0000 		lds r24,__iob+4
 843 03a6 9091 0000 		lds r25,(__iob+4)+1
 844 03aa 9F93      		push r25
 845 03ac 8F93      		push r24
 846 03ae 0E94 0000 		call fprintf
 847 03b2 8091 0000 		lds r24,adc_offset+4
 848 03b6 9091 0000 		lds r25,(adc_offset+4)+1
 849 03ba 9F93      		push r25
 850 03bc 8F93      		push r24
 851 03be 82E0      		ldi r24,lo8(2)
 852 03c0 90E0      		ldi r25,hi8(2)
 853 03c2 9F93      		push r25
 854 03c4 8F93      		push r24
 855 03c6 1F93      		push r17
 856 03c8 0F93      		push r16
 857 03ca 8091 0000 		lds r24,__iob+4
 858 03ce 9091 0000 		lds r25,(__iob+4)+1
 859 03d2 9F93      		push r25
 860 03d4 8F93      		push r24
 861 03d6 0E94 0000 		call fprintf
 862 03da 8091 0000 		lds r24,adc_offset+6
 863 03de 9091 0000 		lds r25,(adc_offset+6)+1
 864 03e2 9F93      		push r25
 865 03e4 8F93      		push r24
 866 03e6 83E0      		ldi r24,lo8(3)
 867 03e8 90E0      		ldi r25,hi8(3)
 868 03ea 9F93      		push r25
 869 03ec 8F93      		push r24
 870 03ee 1F93      		push r17
 871 03f0 0F93      		push r16
 872 03f2 8091 0000 		lds r24,__iob+4
 873 03f6 9091 0000 		lds r25,(__iob+4)+1
 874 03fa 9F93      		push r25
 875 03fc 8F93      		push r24
 876 03fe 0E94 0000 		call fprintf
 877 0402 8DB7      		in r24,__SP_L__
 878 0404 9EB7      		in r25,__SP_H__
 879 0406 8496      		adiw r24,36
 880 0408 0FB6      		in __tmp_reg__,__SREG__
 881 040a F894      		cli
 882 040c 9EBF      		out __SP_H__,r25
 883 040e 0FBE      		out __SREG__,__tmp_reg__
 884 0410 8DBF      		out __SP_L__,r24
 885               	/* epilogue start */
 886               	.LBE29:
 888               	.LM67:
 889 0412 1F91      		pop r17
 890 0414 0F91      		pop r16
 891 0416 0895      		ret
 893               	.Lscope11:
 895               	.global	print_adc_values
 897               	print_adc_values:
 899               	.LM68:
 900               	.LFBB12:
 901 0418 CF92      		push r12
 902 041a DF92      		push r13
 903 041c EF92      		push r14
 904 041e FF92      		push r15
 905 0420 0F93      		push r16
 906 0422 1F93      		push r17
 907 0424 CF93      		push r28
 908 0426 DF93      		push r29
 909               	/* prologue: function */
 910               	/* frame size = 0 */
 912               	.LM69:
 913 0428 80E0      		ldi r24,lo8(__c.1738)
 914 042a 90E0      		ldi r25,hi8(__c.1738)
 915 042c 9F93      		push r25
 916 042e 8F93      		push r24
 917 0430 8091 0000 		lds r24,__iob+4
 918 0434 9091 0000 		lds r25,(__iob+4)+1
 919 0438 9F93      		push r25
 920 043a 8F93      		push r24
 921 043c 0E94 0000 		call fprintf_P
 922               	.LBB30:
 924               	.LM70:
 925 0440 8091 0000 		lds r24,adc_val
 926 0444 9091 0000 		lds r25,(adc_val)+1
 927 0448 9F93      		push r25
 928 044a 8F93      		push r24
 929 044c 1F92      		push __zero_reg__
 930 044e 1F92      		push __zero_reg__
 931 0450 00E0      		ldi r16,lo8(.LC0)
 932 0452 10E0      		ldi r17,hi8(.LC0)
 933 0454 1F93      		push r17
 934 0456 0F93      		push r16
 935 0458 8091 0000 		lds r24,__iob+4
 936 045c 9091 0000 		lds r25,(__iob+4)+1
 937 0460 9F93      		push r25
 938 0462 8F93      		push r24
 939 0464 0E94 0000 		call fprintf
 940 0468 8091 0000 		lds r24,adc_val+2
 941 046c 9091 0000 		lds r25,(adc_val+2)+1
 942 0470 9F93      		push r25
 943 0472 8F93      		push r24
 944 0474 81E0      		ldi r24,lo8(1)
 945 0476 90E0      		ldi r25,hi8(1)
 946 0478 9F93      		push r25
 947 047a 8F93      		push r24
 948 047c 1F93      		push r17
 949 047e 0F93      		push r16
 950 0480 8091 0000 		lds r24,__iob+4
 951 0484 9091 0000 		lds r25,(__iob+4)+1
 952 0488 9F93      		push r25
 953 048a 8F93      		push r24
 954 048c 0E94 0000 		call fprintf
 955 0490 8091 0000 		lds r24,adc_val+4
 956 0494 9091 0000 		lds r25,(adc_val+4)+1
 957 0498 9F93      		push r25
 958 049a 8F93      		push r24
 959 049c 82E0      		ldi r24,lo8(2)
 960 049e 90E0      		ldi r25,hi8(2)
 961 04a0 9F93      		push r25
 962 04a2 8F93      		push r24
 963 04a4 1F93      		push r17
 964 04a6 0F93      		push r16
 965 04a8 8091 0000 		lds r24,__iob+4
 966 04ac 9091 0000 		lds r25,(__iob+4)+1
 967 04b0 9F93      		push r25
 968 04b2 8F93      		push r24
 969 04b4 0E94 0000 		call fprintf
 970 04b8 8091 0000 		lds r24,adc_val+6
 971 04bc 9091 0000 		lds r25,(adc_val+6)+1
 972 04c0 9F93      		push r25
 973 04c2 8F93      		push r24
 974 04c4 83E0      		ldi r24,lo8(3)
 975 04c6 90E0      		ldi r25,hi8(3)
 976 04c8 9F93      		push r25
 977 04ca 8F93      		push r24
 978 04cc 1F93      		push r17
 979 04ce 0F93      		push r16
 980 04d0 8091 0000 		lds r24,__iob+4
 981 04d4 9091 0000 		lds r25,(__iob+4)+1
 982 04d8 9F93      		push r25
 983 04da 8F93      		push r24
 984 04dc 0E94 0000 		call fprintf
 985               	.LBE30:
 987               	.LM71:
 988 04e0 8DB7      		in r24,__SP_L__
 989 04e2 9EB7      		in r25,__SP_H__
 990 04e4 8496      		adiw r24,36
 991 04e6 0FB6      		in __tmp_reg__,__SREG__
 992 04e8 F894      		cli
 993 04ea 9EBF      		out __SP_H__,r25
 994 04ec 0FBE      		out __SREG__,__tmp_reg__
 995 04ee 8DBF      		out __SP_L__,r24
 996 04f0 80E0      		ldi r24,lo8(__c.1744)
 997 04f2 90E0      		ldi r25,hi8(__c.1744)
 998 04f4 9F93      		push r25
 999 04f6 8F93      		push r24
 1000 04f8 8091 0000 		lds r24,__iob+4
 1001 04fc 9091 0000 		lds r25,(__iob+4)+1
 1002 0500 9F93      		push r25
 1003 0502 8F93      		push r24
 1004 0504 0E94 0000 		call fprintf_P
 1005 0508 40E0      		ldi r20,lo8(adc_val)
 1006 050a C42E      		mov r12,r20
 1007 050c 40E0      		ldi r20,hi8(adc_val)
 1008 050e D42E      		mov r13,r20
 1009 0510 30E0      		ldi r19,lo8(adc_offset)
 1010 0512 E32E      		mov r14,r19
 1011 0514 30E0      		ldi r19,hi8(adc_offset)
 1012 0516 F32E      		mov r15,r19
 1013 0518 C0E0      		ldi r28,lo8(0)
 1014 051a D0E0      		ldi r29,hi8(0)
 1015 051c 0F90      		pop __tmp_reg__
 1016 051e 0F90      		pop __tmp_reg__
 1017 0520 0F90      		pop __tmp_reg__
 1018 0522 0F90      		pop __tmp_reg__
 1019               	.L39:
 1020               	.LBB31:
 1022               	.LM72:
 1023 0524 F701      		movw r30,r14
 1024 0526 8191      		ld r24,Z+
 1025 0528 9191      		ld r25,Z+
 1026 052a 7F01      		movw r14,r30
 1027 052c F601      		movw r30,r12
 1028 052e 2191      		ld r18,Z+
 1029 0530 3191      		ld r19,Z+
 1030 0532 6F01      		movw r12,r30
 1031 0534 820F      		add r24,r18
 1032 0536 931F      		adc r25,r19
 1033 0538 9F93      		push r25
 1034 053a 8F93      		push r24
 1035 053c DF93      		push r29
 1036 053e CF93      		push r28
 1037 0540 1F93      		push r17
 1038 0542 0F93      		push r16
 1039 0544 8091 0000 		lds r24,__iob+4
 1040 0548 9091 0000 		lds r25,(__iob+4)+1
 1041 054c 9F93      		push r25
 1042 054e 8F93      		push r24
 1043 0550 0E94 0000 		call fprintf
 1044 0554 2196      		adiw r28,1
 1046               	.LM73:
 1047 0556 8DB7      		in r24,__SP_L__
 1048 0558 9EB7      		in r25,__SP_H__
 1049 055a 0896      		adiw r24,8
 1050 055c 0FB6      		in __tmp_reg__,__SREG__
 1051 055e F894      		cli
 1052 0560 9EBF      		out __SP_H__,r25
 1053 0562 0FBE      		out __SREG__,__tmp_reg__
 1054 0564 8DBF      		out __SP_L__,r24
 1055 0566 C430      		cpi r28,4
 1056 0568 D105      		cpc r29,__zero_reg__
 1057 056a 01F4      		brne .L39
 1058               	/* epilogue start */
 1059               	.LBE31:
 1061               	.LM74:
 1062 056c DF91      		pop r29
 1063 056e CF91      		pop r28
 1064 0570 1F91      		pop r17
 1065 0572 0F91      		pop r16
 1066 0574 FF90      		pop r15
 1067 0576 EF90      		pop r14
 1068 0578 DF90      		pop r13
 1069 057a CF90      		pop r12
 1070 057c 0895      		ret
 1072               	.Lscope12:
 1073               		.lcomm ct.1881,1
 1074               		.data
 1077               	channels:
 1078 000e 04        		.byte	4
 1079 000f 06        		.byte	6
 1080 0010 05        		.byte	5
 1081 0011 07        		.byte	7
 1082               		.section	.progmem.data,"a",@progbits
 1085               	__c.1825:
 1086 0000 095B 646F 		.string	"\t[done]"
 1086      6E65 5D00 
 1089               	__c.1823:
 1090 0008 0A61 6463 		.string	"\nadc: init: setup convertions"
 1090      3A20 696E 
 1090      6974 3A20 
 1090      7365 7475 
 1090      7020 636F 
 1093               	__c.1821:
 1094 0026 0A61 6463 		.string	"\nadc: init"
 1094      3A20 696E 
 1094      6974 00
 1097               	__c.1814:
 1098 0031 0A5B 64   		.ascii	"\n[d"
 1099 0034 6562 7567 		.string	"ebug] Warning: unimplimented function adc_calibrate_store called"
 1099      5D20 5761 
 1099      726E 696E 
 1099      673A 2075 
 1099      6E69 6D70 
 1102               	__c.1757:
 1103 0075 0A5B 6465 		.string	"\n[debug] ADC OFFSETS: "
 1103      6275 675D 
 1103      2041 4443 
 1103      204F 4646 
 1103      5345 5453 
 1106               	__c.1744:
 1107 008c 0A5B 6465 		.string	"\n[debug] FIXED ADC: "
 1107      6275 675D 
 1107      2046 4958 
 1107      4544 2041 
 1107      4443 3A20 
 1110               	__c.1738:
 1111 00a1 0A5B 6465 		.string	"\n[debug]   RAW ADC: "
 1111      6275 675D 
 1111      2020 2052 
 1111      4157 2041 
 1111      4443 3A20 
 1112               		.lcomm num_calibrations,1
 1113               		.comm c_mode,1,1
 1114               		.comm initial,1,1
 1115               		.comm adc_val,8,1
 1116               		.comm adc_offset,8,1
 1117               		.comm adc_amt,8,1
 1118               		.comm curr_ch,1,1
 1119               		.comm new_adc_data,1,1
 1137               		.text
 1139               	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 adc.c
     /tmp/cc0Fmz6U.s:2      *ABS*:0000003f __SREG__
     /tmp/cc0Fmz6U.s:3      *ABS*:0000003e __SP_H__
     /tmp/cc0Fmz6U.s:4      *ABS*:0000003d __SP_L__
     /tmp/cc0Fmz6U.s:5      *ABS*:00000000 __tmp_reg__
     /tmp/cc0Fmz6U.s:6      *ABS*:00000001 __zero_reg__
     /tmp/cc0Fmz6U.s:104    .text:00000000 copysign
     /tmp/cc0Fmz6U.s:130    .text:00000006 isfinite
     /tmp/cc0Fmz6U.s:168    .text:0000001e max
     /tmp/cc0Fmz6U.s:187    .text:00000022 adc_get_val
                            *COM*:00000008 adc_val
                            *COM*:00000008 adc_offset
     /tmp/cc0Fmz6U.s:221    .text:00000044 adc_set_channel
     /tmp/cc0Fmz6U.s:1077   .data:0000000e channels
     /tmp/cc0Fmz6U.s:249    .text:0000005c __vector_19
                             .bss:00000000 ct.1881
                            *COM*:00000001 curr_ch
                            *COM*:00000008 adc_amt
                            *COM*:00000001 new_adc_data
     /tmp/cc0Fmz6U.s:381    .text:0000011a adc_init
     /tmp/cc0Fmz6U.s:1093   .progmem.data:00000026 __c.1821
     /tmp/cc0Fmz6U.s:1089   .progmem.data:00000008 __c.1823
     /tmp/cc0Fmz6U.s:1085   .progmem.data:00000000 __c.1825
     /tmp/cc0Fmz6U.s:571    .text:0000021a adc_calibrate_store
     /tmp/cc0Fmz6U.s:1097   .progmem.data:00000031 __c.1814
     /tmp/cc0Fmz6U.s:601    .text:0000023c adc_calibrate_clear
     /tmp/cc0Fmz6U.s:1073   .bss:00000001 num_calibrations
     /tmp/cc0Fmz6U.s:628    .text:00000250 adc_calibrate_update
     /tmp/cc0Fmz6U.s:795    .text:00000346 print_adc_calibration
     /tmp/cc0Fmz6U.s:1102   .progmem.data:00000075 __c.1757
     /tmp/cc0Fmz6U.s:897    .text:00000418 print_adc_values
     /tmp/cc0Fmz6U.s:1110   .progmem.data:000000a1 __c.1738
     /tmp/cc0Fmz6U.s:1106   .progmem.data:0000008c __c.1744
                            *COM*:00000001 c_mode
                            *COM*:00000001 initial

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
__iob
fprintf_P
__divmodhi4
fprintf
